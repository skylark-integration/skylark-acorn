{"version":3,"sources":["expression.js"],"names":["define","tt","tokenCtxTypes","m_state","m_parseutil","m_whitespace","m_scopeflags","Parser","DestructuringErrors","lineBreak","functionFlags","SCOPE_ARROW","SCOPE_SUPER","SCOPE_DIRECT_SUPER","BIND_OUTSIDE","BIND_VAR","pp","prototype","checkPropClash","prop","propHash","refDestructuringErrors","this","options","ecmaVersion","type","computed","method","shorthand","name","key","String","value","kind","proto","doubleProto","start","raiseRecoverable","other","redefinition","strict","init","get","set","parseExpression","forInit","startPos","startLoc","expr","parseMaybeAssign","comma","node","startNodeAt","expressions","eat","push","finishNode","afterLeftParse","isContextual","inGenerator","parseYield","exprAllowed","ownDestructuringErrors","oldParenAssign","oldTrailingComma","oldDoubleProto","parenthesizedAssign","trailingComma","parenL","potentialArrowAt","potentialArrowInForAwait","left","parseMaybeConditional","call","isAssign","operator","eq","toAssignable","shorthandAssign","checkLValPattern","checkLValSimple","next","right","checkExpressionErrors","parseExprOps","question","test","consequent","expect","colon","alternate","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","prec","binop","_in","logical","logicalOR","logicalAND","coalesce","op","buildBinary","raise","sawUnary","incDec","canAwait","parseAwait","prefix","startNode","update","argument","isPrivateFieldAccess","property","expression","privateId","parseExprSubscripts","postfix","canInsertSemicolon","privateNameStack","length","checkPrivateFields","unexpected","parsePrivateIdent","starstar","lastTokStart","parseExprAtom","input","slice","lastTokEnd","result","parseSubscripts","parenthesizedBind","base","noCalls","maybeAsyncArrow","end","optionalChained","element","parseSubscript","optional","chainNode","shouldParseAsyncArrow","arrow","parseSubscriptAsyncArrow","exprList","parseArrowExpression","optionalSupported","questionDot","bracketL","backQuote","dot","object","bracketR","parseIdent","allowReserved","oldYieldPos","yieldPos","oldAwaitPos","awaitPos","oldAwaitIdentPos","awaitIdentPos","parseExprList","parenR","checkPatternErrors","checkYieldAwaitInDefaultParams","callee","arguments","tag","quasi","parseTemplate","isTagged","forNew","slash","readRegexp","canBeArrow","_super","allowSuper","allowDirectSuper","_this","containsEsc","id","_function","overrideContext","f_expr","parseFunction","regexp","parseLiteral","regex","pattern","flags","num","string","_null","_true","_false","raw","keyword","parseParenAndDistinguishExpression","isSimpleAssignTarget","elements","braceL","b_expr","parseObj","_class","parseClass","_new","parseNew","_import","parseExprImport","parseExprAtomDefault","meta","parseImportMeta","parseDynamicImport","source","errorPos","sourceType","allowImportExportEverywhere","charCodeAt","bigint","replace","parseParenExpression","val","shouldParseArrow","allowTrailingComma","spreadStart","innerStartPos","innerStartLoc","first","lastIsComma","afterTrailingComma","ellipsis","parseParenItem","parseRestBinding","innerEndPos","innerEndLoc","lastTokEndLoc","parseParenArrowList","finishNodeAt","preserveParens","par","item","empty","allowNewDotTarget","parseTemplateElement","elem","invalidTemplate","cooked","tail","curElt","quasis","eof","pos","dollarBraceL","braceR","isAsyncProp","star","isPattern","properties","parseProperty","isGenerator","isAsync","parsePropertyName","parsePropertyValue","parseGetterSetter","parseMethod","paramCount","params","parseMaybeDefault","checkUnreserved","copyNode","initFunction","generator","async","enterScope","parseBindingList","parseFunctionBody","toAssignableList","isArrowFunction","isMethod","isExpression","oldStrict","useStrict","body","checkParams","nonSimple","isSimpleParamList","strictDirective","oldLabels","labels","parseBlock","undefined","adaptDirectivePrologue","exitScope","param","allowDuplicates","nameHash","Object","create","checkLValInnerPattern","close","allowEmpty","elts","elt","parseSpread","inAsync","currentThisScope","inClassFieldInit","inClassStaticBlock","keywords","indexOf","reservedWordsStrict","reservedWords","liberal","parseIdentNode","context","pop","used","semi","startsExpr","delegate"],"mappings":"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","file":"../expression.js","sourcesContent":["define([\n    './tokentype',\n    './tokencontext',\n    './state',\n    './parseutil',\n    './whitespace',\n    './scopeflags'\n], function (tt, tokenCtxTypes, m_state, m_parseutil, m_whitespace, m_scopeflags) {\n    'use strict';\n    const {Parser} = m_state;\n    const {DestructuringErrors} = m_parseutil;\n    const {lineBreak} = m_whitespace;\n    const {functionFlags, SCOPE_ARROW, SCOPE_SUPER, SCOPE_DIRECT_SUPER, BIND_OUTSIDE, BIND_VAR} = m_scopeflags;\n    const pp = Parser.prototype;\n    pp.checkPropClash = function (prop, propHash, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 9 && prop.type === 'SpreadElement')\n            return;\n        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n            return;\n        let {key} = prop, name;\n        switch (key.type) {\n        case 'Identifier':\n            name = key.name;\n            break;\n        case 'Literal':\n            name = String(key.value);\n            break;\n        default:\n            return;\n        }\n        let {kind} = prop;\n        if (this.options.ecmaVersion >= 6) {\n            if (name === '__proto__' && kind === 'init') {\n                if (propHash.proto) {\n                    if (refDestructuringErrors) {\n                        if (refDestructuringErrors.doubleProto < 0) {\n                            refDestructuringErrors.doubleProto = key.start;\n                        }\n                    } else {\n                        this.raiseRecoverable(key.start, 'Redefinition of __proto__ property');\n                    }\n                }\n                propHash.proto = true;\n            }\n            return;\n        }\n        name = '$' + name;\n        let other = propHash[name];\n        if (other) {\n            let redefinition;\n            if (kind === 'init') {\n                redefinition = this.strict && other.init || other.get || other.set;\n            } else {\n                redefinition = other.init || other[kind];\n            }\n            if (redefinition)\n                this.raiseRecoverable(key.start, 'Redefinition of property');\n        } else {\n            other = propHash[name] = {\n                init: false,\n                get: false,\n                set: false\n            };\n        }\n        other[kind] = true;\n    };\n    pp.parseExpression = function (forInit, refDestructuringErrors) {\n        let startPos = this.start, startLoc = this.startLoc;\n        let expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n        if (this.type === tt.comma) {\n            let node = this.startNodeAt(startPos, startLoc);\n            node.expressions = [expr];\n            while (this.eat(tt.comma))\n                node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n            return this.finishNode(node, 'SequenceExpression');\n        }\n        return expr;\n    };\n    pp.parseMaybeAssign = function (forInit, refDestructuringErrors, afterLeftParse) {\n        if (this.isContextual('yield')) {\n            if (this.inGenerator)\n                return this.parseYield(forInit);\n            else\n                this.exprAllowed = false;\n        }\n        let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n        if (refDestructuringErrors) {\n            oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n            oldTrailingComma = refDestructuringErrors.trailingComma;\n            oldDoubleProto = refDestructuringErrors.doubleProto;\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n        } else {\n            refDestructuringErrors = new DestructuringErrors();\n            ownDestructuringErrors = true;\n        }\n        let startPos = this.start, startLoc = this.startLoc;\n        if (this.type === tt.parenL || this.type === tt.name) {\n            this.potentialArrowAt = this.start;\n            this.potentialArrowInForAwait = forInit === 'await';\n        }\n        let left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n        if (afterLeftParse)\n            left = afterLeftParse.call(this, left, startPos, startLoc);\n        if (this.type.isAssign) {\n            let node = this.startNodeAt(startPos, startLoc);\n            node.operator = this.value;\n            if (this.type === tt.eq)\n                left = this.toAssignable(left, false, refDestructuringErrors);\n            if (!ownDestructuringErrors) {\n                refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n            }\n            if (refDestructuringErrors.shorthandAssign >= left.start)\n                refDestructuringErrors.shorthandAssign = -1;\n            if (this.type === tt.eq)\n                this.checkLValPattern(left);\n            else\n                this.checkLValSimple(left);\n            node.left = left;\n            this.next();\n            node.right = this.parseMaybeAssign(forInit);\n            if (oldDoubleProto > -1)\n                refDestructuringErrors.doubleProto = oldDoubleProto;\n            return this.finishNode(node, 'AssignmentExpression');\n        } else {\n            if (ownDestructuringErrors)\n                this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n        if (oldParenAssign > -1)\n            refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n        if (oldTrailingComma > -1)\n            refDestructuringErrors.trailingComma = oldTrailingComma;\n        return left;\n    };\n    pp.parseMaybeConditional = function (forInit, refDestructuringErrors) {\n        let startPos = this.start, startLoc = this.startLoc;\n        let expr = this.parseExprOps(forInit, refDestructuringErrors);\n        if (this.checkExpressionErrors(refDestructuringErrors))\n            return expr;\n        if (this.eat(tt.question)) {\n            let node = this.startNodeAt(startPos, startLoc);\n            node.test = expr;\n            node.consequent = this.parseMaybeAssign();\n            this.expect(tt.colon);\n            node.alternate = this.parseMaybeAssign(forInit);\n            return this.finishNode(node, 'ConditionalExpression');\n        }\n        return expr;\n    };\n    pp.parseExprOps = function (forInit, refDestructuringErrors) {\n        let startPos = this.start, startLoc = this.startLoc;\n        let expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors))\n            return expr;\n        return expr.start === startPos && expr.type === 'ArrowFunctionExpression' ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n    };\n    pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, forInit) {\n        let prec = this.type.binop;\n        if (prec != null && (!forInit || this.type !== tt._in)) {\n            if (prec > minPrec) {\n                let logical = this.type === tt.logicalOR || this.type === tt.logicalAND;\n                let coalesce = this.type === tt.coalesce;\n                if (coalesce) {\n                    prec = tt.logicalAND.binop;\n                }\n                let op = this.value;\n                this.next();\n                let startPos = this.start, startLoc = this.startLoc;\n                let right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n                let node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n                if (logical && this.type === tt.coalesce || coalesce && (this.type === tt.logicalOR || this.type === tt.logicalAND)) {\n                    this.raiseRecoverable(this.start, 'Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses');\n                }\n                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n            }\n        }\n        return left;\n    };\n    pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {\n        if (right.type === 'PrivateIdentifier')\n            this.raise(right.start, 'Private identifier can only be left side of binary expression');\n        let node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.operator = op;\n        node.right = right;\n        return this.finishNode(node, logical ? 'LogicalExpression' : 'BinaryExpression');\n    };\n    pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary, incDec, forInit) {\n        let startPos = this.start, startLoc = this.startLoc, expr;\n        if (this.isContextual('await') && this.canAwait) {\n            expr = this.parseAwait(forInit);\n            sawUnary = true;\n        } else if (this.type.prefix) {\n            let node = this.startNode(), update = this.type === tt.incDec;\n            node.operator = this.value;\n            node.prefix = true;\n            this.next();\n            node.argument = this.parseMaybeUnary(null, true, update, forInit);\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            if (update)\n                this.checkLValSimple(node.argument);\n            else if (this.strict && node.operator === 'delete' && node.argument.type === 'Identifier')\n                this.raiseRecoverable(node.start, 'Deleting local variable in strict mode');\n            else if (node.operator === 'delete' && isPrivateFieldAccess(node.argument))\n                this.raiseRecoverable(node.start, 'Private fields can not be deleted');\n            else\n                sawUnary = true;\n            expr = this.finishNode(node, update ? 'UpdateExpression' : 'UnaryExpression');\n        } else if (!sawUnary && this.type === tt.privateId) {\n            if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields)\n                this.unexpected();\n            expr = this.parsePrivateIdent();\n            if (this.type !== tt._in)\n                this.unexpected();\n        } else {\n            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n            if (this.checkExpressionErrors(refDestructuringErrors))\n                return expr;\n            while (this.type.postfix && !this.canInsertSemicolon()) {\n                let node = this.startNodeAt(startPos, startLoc);\n                node.operator = this.value;\n                node.prefix = false;\n                node.argument = expr;\n                this.checkLValSimple(expr);\n                this.next();\n                expr = this.finishNode(node, 'UpdateExpression');\n            }\n        }\n        if (!incDec && this.eat(tt.starstar)) {\n            if (sawUnary)\n                this.unexpected(this.lastTokStart);\n            else\n                return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), '**', false);\n        } else {\n            return expr;\n        }\n    };\n    function isPrivateFieldAccess(node) {\n        return node.type === 'MemberExpression' && node.property.type === 'PrivateIdentifier' || node.type === 'ChainExpression' && isPrivateFieldAccess(node.expression);\n    }\n    pp.parseExprSubscripts = function (refDestructuringErrors, forInit) {\n        let startPos = this.start, startLoc = this.startLoc;\n        let expr = this.parseExprAtom(refDestructuringErrors, forInit);\n        if (expr.type === 'ArrowFunctionExpression' && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ')')\n            return expr;\n        let result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n        if (refDestructuringErrors && result.type === 'MemberExpression') {\n            if (refDestructuringErrors.parenthesizedAssign >= result.start)\n                refDestructuringErrors.parenthesizedAssign = -1;\n            if (refDestructuringErrors.parenthesizedBind >= result.start)\n                refDestructuringErrors.parenthesizedBind = -1;\n            if (refDestructuringErrors.trailingComma >= result.start)\n                refDestructuringErrors.trailingComma = -1;\n        }\n        return result;\n    };\n    pp.parseSubscripts = function (base, startPos, startLoc, noCalls, forInit) {\n        let maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === 'Identifier' && base.name === 'async' && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n        let optionalChained = false;\n        while (true) {\n            let element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n            if (element.optional)\n                optionalChained = true;\n            if (element === base || element.type === 'ArrowFunctionExpression') {\n                if (optionalChained) {\n                    const chainNode = this.startNodeAt(startPos, startLoc);\n                    chainNode.expression = element;\n                    element = this.finishNode(chainNode, 'ChainExpression');\n                }\n                return element;\n            }\n            base = element;\n        }\n    };\n    pp.shouldParseAsyncArrow = function () {\n        return !this.canInsertSemicolon() && this.eat(tt.arrow);\n    };\n    pp.parseSubscriptAsyncArrow = function (startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n    };\n    pp.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n        let optionalSupported = this.options.ecmaVersion >= 11;\n        let optional = optionalSupported && this.eat(tt.questionDot);\n        if (noCalls && optional)\n            this.raise(this.lastTokStart, 'Optional chaining cannot appear in the callee of new expressions');\n        let computed = this.eat(tt.bracketL);\n        if (computed || optional && this.type !== tt.parenL && this.type !== tt.backQuote || this.eat(tt.dot)) {\n            let node = this.startNodeAt(startPos, startLoc);\n            node.object = base;\n            if (computed) {\n                node.property = this.parseExpression();\n                this.expect(tt.bracketR);\n            } else if (this.type === tt.privateId && base.type !== 'Super') {\n                node.property = this.parsePrivateIdent();\n            } else {\n                node.property = this.parseIdent(this.options.allowReserved !== 'never');\n            }\n            node.computed = !!computed;\n            if (optionalSupported) {\n                node.optional = optional;\n            }\n            base = this.finishNode(node, 'MemberExpression');\n        } else if (!noCalls && this.eat(tt.parenL)) {\n            let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            this.awaitIdentPos = 0;\n            let exprList = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                if (this.awaitIdentPos > 0)\n                    this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                this.awaitIdentPos = oldAwaitIdentPos;\n                return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n            }\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n            let node = this.startNodeAt(startPos, startLoc);\n            node.callee = base;\n            node.arguments = exprList;\n            if (optionalSupported) {\n                node.optional = optional;\n            }\n            base = this.finishNode(node, 'CallExpression');\n        } else if (this.type === tt.backQuote) {\n            if (optional || optionalChained) {\n                this.raise(this.start, 'Optional chaining cannot appear in the tag of tagged template expressions');\n            }\n            let node = this.startNodeAt(startPos, startLoc);\n            node.tag = base;\n            node.quasi = this.parseTemplate({ isTagged: true });\n            base = this.finishNode(node, 'TaggedTemplateExpression');\n        }\n        return base;\n    };\n    pp.parseExprAtom = function (refDestructuringErrors, forInit, forNew) {\n        if (this.type === tt.slash)\n            this.readRegexp();\n        let node, canBeArrow = this.potentialArrowAt === this.start;\n        switch (this.type) {\n        case tt._super:\n            if (!this.allowSuper)\n                this.raise(this.start, \"'super' keyword outside a method\");\n            node = this.startNode();\n            this.next();\n            if (this.type === tt.parenL && !this.allowDirectSuper)\n                this.raise(node.start, 'super() call outside constructor of a subclass');\n            if (this.type !== tt.dot && this.type !== tt.bracketL && this.type !== tt.parenL)\n                this.unexpected();\n            return this.finishNode(node, 'Super');\n        case tt._this:\n            node = this.startNode();\n            this.next();\n            return this.finishNode(node, 'ThisExpression');\n        case tt.name:\n            let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n            let id = this.parseIdent(false);\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === 'async' && !this.canInsertSemicolon() && this.eat(tt._function)) {\n                this.overrideContext(tokenCtxTypes.f_expr);\n                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n            }\n            if (canBeArrow && !this.canInsertSemicolon()) {\n                if (this.eat(tt.arrow))\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);\n                if (this.options.ecmaVersion >= 8 && id.name === 'async' && this.type === tt.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== 'of' || this.containsEsc)) {\n                    id = this.parseIdent(false);\n                    if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n                        this.unexpected();\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);\n                }\n            }\n            return id;\n        case tt.regexp:\n            let value = this.value;\n            node = this.parseLiteral(value.value);\n            node.regex = {\n                pattern: value.pattern,\n                flags: value.flags\n            };\n            return node;\n        case tt.num:\n        case tt.string:\n            return this.parseLiteral(this.value);\n        case tt._null:\n        case tt._true:\n        case tt._false:\n            node = this.startNode();\n            node.value = this.type === tt._null ? null : this.type === tt._true;\n            node.raw = this.type.keyword;\n            this.next();\n            return this.finishNode(node, 'Literal');\n        case tt.parenL:\n            let start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n            if (refDestructuringErrors) {\n                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n                    refDestructuringErrors.parenthesizedAssign = start;\n                if (refDestructuringErrors.parenthesizedBind < 0)\n                    refDestructuringErrors.parenthesizedBind = start;\n            }\n            return expr;\n        case tt.bracketL:\n            node = this.startNode();\n            this.next();\n            node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors);\n            return this.finishNode(node, 'ArrayExpression');\n        case tt.braceL:\n            this.overrideContext(tokenCtxTypes.b_expr);\n            return this.parseObj(false, refDestructuringErrors);\n        case tt._function:\n            node = this.startNode();\n            this.next();\n            return this.parseFunction(node, 0);\n        case tt._class:\n            return this.parseClass(this.startNode(), false);\n        case tt._new:\n            return this.parseNew();\n        case tt.backQuote:\n            return this.parseTemplate();\n        case tt._import:\n            if (this.options.ecmaVersion >= 11) {\n                return this.parseExprImport(forNew);\n            } else {\n                return this.unexpected();\n            }\n        default:\n            return this.parseExprAtomDefault();\n        }\n    };\n    pp.parseExprAtomDefault = function () {\n        this.unexpected();\n    };\n    pp.parseExprImport = function (forNew) {\n        const node = this.startNode();\n        if (this.containsEsc)\n            this.raiseRecoverable(this.start, 'Escape sequence in keyword import');\n        const meta = this.parseIdent(true);\n        if (this.type === tt.parenL && !forNew) {\n            return this.parseDynamicImport(node);\n        } else if (this.type === tt.dot) {\n            node.meta = meta;\n            return this.parseImportMeta(node);\n        } else {\n            this.unexpected();\n        }\n    };\n    pp.parseDynamicImport = function (node) {\n        this.next();\n        node.source = this.parseMaybeAssign();\n        if (!this.eat(tt.parenR)) {\n            const errorPos = this.start;\n            if (this.eat(tt.comma) && this.eat(tt.parenR)) {\n                this.raiseRecoverable(errorPos, 'Trailing comma is not allowed in import()');\n            } else {\n                this.unexpected(errorPos);\n            }\n        }\n        return this.finishNode(node, 'ImportExpression');\n    };\n    pp.parseImportMeta = function (node) {\n        this.next();\n        const containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== 'meta')\n            this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n        if (containsEsc)\n            this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n        if (this.options.sourceType !== 'module' && !this.options.allowImportExportEverywhere)\n            this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n        return this.finishNode(node, 'MetaProperty');\n    };\n    pp.parseLiteral = function (value) {\n        let node = this.startNode();\n        node.value = value;\n        node.raw = this.input.slice(this.start, this.end);\n        if (node.raw.charCodeAt(node.raw.length - 1) === 110)\n            node.bigint = node.raw.slice(0, -1).replace(/_/g, '');\n        this.next();\n        return this.finishNode(node, 'Literal');\n    };\n    pp.parseParenExpression = function () {\n        this.expect(tt.parenL);\n        let val = this.parseExpression();\n        this.expect(tt.parenR);\n        return val;\n    };\n    pp.shouldParseArrow = function (exprList) {\n        return !this.canInsertSemicolon();\n    };\n    pp.parseParenAndDistinguishExpression = function (canBeArrow, forInit) {\n        let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n        if (this.options.ecmaVersion >= 6) {\n            this.next();\n            let innerStartPos = this.start, innerStartLoc = this.startLoc;\n            let exprList = [], first = true, lastIsComma = false;\n            let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            while (this.type !== tt.parenR) {\n                first ? first = false : this.expect(tt.comma);\n                if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {\n                    lastIsComma = true;\n                    break;\n                } else if (this.type === tt.ellipsis) {\n                    spreadStart = this.start;\n                    exprList.push(this.parseParenItem(this.parseRestBinding()));\n                    if (this.type === tt.comma) {\n                        this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element');\n                    }\n                    break;\n                } else {\n                    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n                }\n            }\n            let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n            this.expect(tt.parenR);\n            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt.arrow)) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n            }\n            if (!exprList.length || lastIsComma)\n                this.unexpected(this.lastTokStart);\n            if (spreadStart)\n                this.unexpected(spreadStart);\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            if (exprList.length > 1) {\n                val = this.startNodeAt(innerStartPos, innerStartLoc);\n                val.expressions = exprList;\n                this.finishNodeAt(val, 'SequenceExpression', innerEndPos, innerEndLoc);\n            } else {\n                val = exprList[0];\n            }\n        } else {\n            val = this.parseParenExpression();\n        }\n        if (this.options.preserveParens) {\n            let par = this.startNodeAt(startPos, startLoc);\n            par.expression = val;\n            return this.finishNode(par, 'ParenthesizedExpression');\n        } else {\n            return val;\n        }\n    };\n    pp.parseParenItem = function (item) {\n        return item;\n    };\n    pp.parseParenArrowList = function (startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n    };\n    const empty = [];\n    pp.parseNew = function () {\n        if (this.containsEsc)\n            this.raiseRecoverable(this.start, 'Escape sequence in keyword new');\n        let node = this.startNode();\n        let meta = this.parseIdent(true);\n        if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n            node.meta = meta;\n            let containsEsc = this.containsEsc;\n            node.property = this.parseIdent(true);\n            if (node.property.name !== 'target')\n                this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n            if (containsEsc)\n                this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n            if (!this.allowNewDotTarget)\n                this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n            return this.finishNode(node, 'MetaProperty');\n        }\n        let startPos = this.start, startLoc = this.startLoc;\n        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n        if (this.eat(tt.parenL))\n            node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false);\n        else\n            node.arguments = empty;\n        return this.finishNode(node, 'NewExpression');\n    };\n    pp.parseTemplateElement = function ({isTagged}) {\n        let elem = this.startNode();\n        if (this.type === tt.invalidTemplate) {\n            if (!isTagged) {\n                this.raiseRecoverable(this.start, 'Bad escape sequence in untagged template literal');\n            }\n            elem.value = {\n                raw: this.value,\n                cooked: null\n            };\n        } else {\n            elem.value = {\n                raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n                cooked: this.value\n            };\n        }\n        this.next();\n        elem.tail = this.type === tt.backQuote;\n        return this.finishNode(elem, 'TemplateElement');\n    };\n    pp.parseTemplate = function ({\n        isTagged = false\n    } = {}) {\n        let node = this.startNode();\n        this.next();\n        node.expressions = [];\n        let curElt = this.parseTemplateElement({ isTagged });\n        node.quasis = [curElt];\n        while (!curElt.tail) {\n            if (this.type === tt.eof)\n                this.raise(this.pos, 'Unterminated template literal');\n            this.expect(tt.dollarBraceL);\n            node.expressions.push(this.parseExpression());\n            this.expect(tt.braceR);\n            node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));\n        }\n        this.next();\n        return this.finishNode(node, 'TemplateLiteral');\n    };\n    pp.isAsyncProp = function (prop) {\n        return !prop.computed && prop.key.type === 'Identifier' && prop.key.name === 'async' && (this.type === tt.name || this.type === tt.num || this.type === tt.string || this.type === tt.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === tt.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    pp.parseObj = function (isPattern, refDestructuringErrors) {\n        let node = this.startNode(), first = true, propHash = {};\n        node.properties = [];\n        this.next();\n        while (!this.eat(tt.braceR)) {\n            if (!first) {\n                this.expect(tt.comma);\n                if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(tt.braceR))\n                    break;\n            } else\n                first = false;\n            const prop = this.parseProperty(isPattern, refDestructuringErrors);\n            if (!isPattern)\n                this.checkPropClash(prop, propHash, refDestructuringErrors);\n            node.properties.push(prop);\n        }\n        return this.finishNode(node, isPattern ? 'ObjectPattern' : 'ObjectExpression');\n    };\n    pp.parseProperty = function (isPattern, refDestructuringErrors) {\n        let prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n        if (this.options.ecmaVersion >= 9 && this.eat(tt.ellipsis)) {\n            if (isPattern) {\n                prop.argument = this.parseIdent(false);\n                if (this.type === tt.comma) {\n                    this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element');\n                }\n                return this.finishNode(prop, 'RestElement');\n            }\n            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n            if (this.type === tt.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n                refDestructuringErrors.trailingComma = this.start;\n            }\n            return this.finishNode(prop, 'SpreadElement');\n        }\n        if (this.options.ecmaVersion >= 6) {\n            prop.method = false;\n            prop.shorthand = false;\n            if (isPattern || refDestructuringErrors) {\n                startPos = this.start;\n                startLoc = this.startLoc;\n            }\n            if (!isPattern)\n                isGenerator = this.eat(tt.star);\n        }\n        let containsEsc = this.containsEsc;\n        this.parsePropertyName(prop);\n        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n            isAsync = true;\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(tt.star);\n            this.parsePropertyName(prop);\n        } else {\n            isAsync = false;\n        }\n        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n        return this.finishNode(prop, 'Property');\n    };\n    pp.parseGetterSetter = function (prop) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n        let paramCount = prop.kind === 'get' ? 0 : 1;\n        if (prop.value.params.length !== paramCount) {\n            let start = prop.value.start;\n            if (prop.kind === 'get')\n                this.raiseRecoverable(start, 'getter should have no params');\n            else\n                this.raiseRecoverable(start, 'setter should have exactly one param');\n        } else {\n            if (prop.kind === 'set' && prop.value.params[0].type === 'RestElement')\n                this.raiseRecoverable(prop.value.params[0].start, 'Setter cannot use rest params');\n        }\n    };\n    pp.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n        if ((isGenerator || isAsync) && this.type === tt.colon)\n            this.unexpected();\n        if (this.eat(tt.colon)) {\n            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n            prop.kind = 'init';\n        } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n            if (isPattern)\n                this.unexpected();\n            prop.kind = 'init';\n            prop.method = true;\n            prop.value = this.parseMethod(isGenerator, isAsync);\n        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === 'Identifier' && (prop.key.name === 'get' || prop.key.name === 'set') && (this.type !== tt.comma && this.type !== tt.braceR && this.type !== tt.eq)) {\n            if (isGenerator || isAsync)\n                this.unexpected();\n            this.parseGetterSetter(prop);\n        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === 'Identifier') {\n            if (isGenerator || isAsync)\n                this.unexpected();\n            this.checkUnreserved(prop.key);\n            if (prop.key.name === 'await' && !this.awaitIdentPos)\n                this.awaitIdentPos = startPos;\n            prop.kind = 'init';\n            if (isPattern) {\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else if (this.type === tt.eq && refDestructuringErrors) {\n                if (refDestructuringErrors.shorthandAssign < 0)\n                    refDestructuringErrors.shorthandAssign = this.start;\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else {\n                prop.value = this.copyNode(prop.key);\n            }\n            prop.shorthand = true;\n        } else\n            this.unexpected();\n    };\n    pp.parsePropertyName = function (prop) {\n        if (this.options.ecmaVersion >= 6) {\n            if (this.eat(tt.bracketL)) {\n                prop.computed = true;\n                prop.key = this.parseMaybeAssign();\n                this.expect(tt.bracketR);\n                return prop.key;\n            } else {\n                prop.computed = false;\n            }\n        }\n        return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== 'never');\n    };\n    pp.initFunction = function (node) {\n        node.id = null;\n        if (this.options.ecmaVersion >= 6)\n            node.generator = node.expression = false;\n        if (this.options.ecmaVersion >= 8)\n            node.async = false;\n    };\n    pp.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {\n        let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 6)\n            node.generator = isGenerator;\n        if (this.options.ecmaVersion >= 8)\n            node.async = !!isAsync;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n        this.expect(tt.parenL);\n        node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n        this.parseFunctionBody(node, false, true, false);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, 'FunctionExpression');\n    };\n    pp.parseArrowExpression = function (node, params, isAsync, forInit) {\n        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 8)\n            node.async = !!isAsync;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        node.params = this.toAssignableList(params, true);\n        this.parseFunctionBody(node, true, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, 'ArrowFunctionExpression');\n    };\n    pp.parseFunctionBody = function (node, isArrowFunction, isMethod, forInit) {\n        let isExpression = isArrowFunction && this.type !== tt.braceL;\n        let oldStrict = this.strict, useStrict = false;\n        if (isExpression) {\n            node.body = this.parseMaybeAssign(forInit);\n            node.expression = true;\n            this.checkParams(node, false);\n        } else {\n            let nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n            if (!oldStrict || nonSimple) {\n                useStrict = this.strictDirective(this.end);\n                if (useStrict && nonSimple)\n                    this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n            }\n            let oldLabels = this.labels;\n            this.labels = [];\n            if (useStrict)\n                this.strict = true;\n            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n            if (this.strict && node.id)\n                this.checkLValSimple(node.id, BIND_OUTSIDE);\n            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n            node.expression = false;\n            this.adaptDirectivePrologue(node.body.body);\n            this.labels = oldLabels;\n        }\n        this.exitScope();\n    };\n    pp.isSimpleParamList = function (params) {\n        for (let param of params)\n            if (param.type !== 'Identifier')\n                return false;\n        return true;\n    };\n    pp.checkParams = function (node, allowDuplicates) {\n        let nameHash = Object.create(null);\n        for (let param of node.params)\n            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    };\n    pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n        let elts = [], first = true;\n        while (!this.eat(close)) {\n            if (!first) {\n                this.expect(tt.comma);\n                if (allowTrailingComma && this.afterTrailingComma(close))\n                    break;\n            } else\n                first = false;\n            let elt;\n            if (allowEmpty && this.type === tt.comma)\n                elt = null;\n            else if (this.type === tt.ellipsis) {\n                elt = this.parseSpread(refDestructuringErrors);\n                if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n                    refDestructuringErrors.trailingComma = this.start;\n            } else {\n                elt = this.parseMaybeAssign(false, refDestructuringErrors);\n            }\n            elts.push(elt);\n        }\n        return elts;\n    };\n    pp.checkUnreserved = function ({start, end, name}) {\n        if (this.inGenerator && name === 'yield')\n            this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n        if (this.inAsync && name === 'await')\n            this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n        if (this.currentThisScope().inClassFieldInit && name === 'arguments')\n            this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n        if (this.inClassStaticBlock && (name === 'arguments' || name === 'await'))\n            this.raise(start, `Cannot use ${ name } in class static initialization block`);\n        if (this.keywords.test(name))\n            this.raise(start, `Unexpected keyword '${ name }'`);\n        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf('\\\\') !== -1)\n            return;\n        const re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n        if (re.test(name)) {\n            if (!this.inAsync && name === 'await')\n                this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n            this.raiseRecoverable(start, `The keyword '${ name }' is reserved`);\n        }\n    };\n    pp.parseIdent = function (liberal) {\n        let node = this.parseIdentNode();\n        this.next(!!liberal);\n        this.finishNode(node, 'Identifier');\n        if (!liberal) {\n            this.checkUnreserved(node);\n            if (node.name === 'await' && !this.awaitIdentPos)\n                this.awaitIdentPos = node.start;\n        }\n        return node;\n    };\n    pp.parseIdentNode = function () {\n        let node = this.startNode();\n        if (this.type === tt.name) {\n            node.name = this.value;\n        } else if (this.type.keyword) {\n            node.name = this.type.keyword;\n            if ((node.name === 'class' || node.name === 'function') && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n                this.context.pop();\n            }\n        } else {\n            this.unexpected();\n        }\n        return node;\n    };\n    pp.parsePrivateIdent = function () {\n        const node = this.startNode();\n        if (this.type === tt.privateId) {\n            node.name = this.value;\n        } else {\n            this.unexpected();\n        }\n        this.next();\n        this.finishNode(node, 'PrivateIdentifier');\n        if (this.options.checkPrivateFields) {\n            if (this.privateNameStack.length === 0) {\n                this.raise(node.start, `Private field '#${ node.name }' must be declared in an enclosing class`);\n            } else {\n                this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n            }\n        }\n        return node;\n    };\n    pp.parseYield = function (forInit) {\n        if (!this.yieldPos)\n            this.yieldPos = this.start;\n        let node = this.startNode();\n        this.next();\n        if (this.type === tt.semi || this.canInsertSemicolon() || this.type !== tt.star && !this.type.startsExpr) {\n            node.delegate = false;\n            node.argument = null;\n        } else {\n            node.delegate = this.eat(tt.star);\n            node.argument = this.parseMaybeAssign(forInit);\n        }\n        return this.finishNode(node, 'YieldExpression');\n    };\n    pp.parseAwait = function (forInit) {\n        if (!this.awaitPos)\n            this.awaitPos = this.start;\n        let node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, false, forInit);\n        return this.finishNode(node, 'AwaitExpression');\n    };\n});"]}