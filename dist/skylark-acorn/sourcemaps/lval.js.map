{"version":3,"sources":["lval.js"],"names":["define","tt","m_state","m_util","m_scopeflags","Parser","hasOwn","BIND_NONE","BIND_OUTSIDE","BIND_LEXICAL","pp","prototype","toAssignable","node","isBinding","refDestructuringErrors","this","options","ecmaVersion","type","inAsync","name","raise","start","checkPatternErrors","prop","properties","argument","kind","key","value","toAssignableList","elements","operator","left","end","expression","raiseRecoverable","exprList","length","i","elt","last","unexpected","parseSpread","startNode","next","parseMaybeAssign","finishNode","parseRestBinding","parseBindingAtom","bracketL","parseBindingList","bracketR","braceL","parseObj","parseIdent","close","allowEmpty","allowTrailingComma","allowModifiers","elts","first","eat","expect","comma","push","afterTrailingComma","ellipsis","rest","parseBindingListItem","parseAssignableListItem","elem","parseMaybeDefault","startLoc","param","startPos","eq","startNodeAt","right","checkLValSimple","expr","bindingType","checkClashes","isBind","strict","reservedWordsStrictBind","test","declareName","checkLValPattern","checkLValInnerPattern"],"mappings":"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","file":"../lval.js","sourcesContent":["define([\n    './tokentype',\n    './state',\n    './util',\n    './scopeflags'\n], function (tt, m_state, m_util, m_scopeflags) {\n    'use strict';\n    const {Parser} = m_state;\n    const {hasOwn} = m_util;\n    const {BIND_NONE, BIND_OUTSIDE, BIND_LEXICAL} = m_scopeflags;\n    const pp = Parser.prototype;\n    pp.toAssignable = function (node, isBinding, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 6 && node) {\n            switch (node.type) {\n            case 'Identifier':\n                if (this.inAsync && node.name === 'await')\n                    this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n                break;\n            case 'ObjectPattern':\n            case 'ArrayPattern':\n            case 'AssignmentPattern':\n            case 'RestElement':\n                break;\n            case 'ObjectExpression':\n                node.type = 'ObjectPattern';\n                if (refDestructuringErrors)\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                for (let prop of node.properties) {\n                    this.toAssignable(prop, isBinding);\n                    if (prop.type === 'RestElement' && (prop.argument.type === 'ArrayPattern' || prop.argument.type === 'ObjectPattern')) {\n                        this.raise(prop.argument.start, 'Unexpected token');\n                    }\n                }\n                break;\n            case 'Property':\n                if (node.kind !== 'init')\n                    this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n                this.toAssignable(node.value, isBinding);\n                break;\n            case 'ArrayExpression':\n                node.type = 'ArrayPattern';\n                if (refDestructuringErrors)\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                this.toAssignableList(node.elements, isBinding);\n                break;\n            case 'SpreadElement':\n                node.type = 'RestElement';\n                this.toAssignable(node.argument, isBinding);\n                if (node.argument.type === 'AssignmentPattern')\n                    this.raise(node.argument.start, 'Rest elements cannot have a default value');\n                break;\n            case 'AssignmentExpression':\n                if (node.operator !== '=')\n                    this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n                node.type = 'AssignmentPattern';\n                delete node.operator;\n                this.toAssignable(node.left, isBinding);\n                break;\n            case 'ParenthesizedExpression':\n                this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n                break;\n            case 'ChainExpression':\n                this.raiseRecoverable(node.start, 'Optional chaining cannot appear in left-hand side');\n                break;\n            case 'MemberExpression':\n                if (!isBinding)\n                    break;\n            default:\n                this.raise(node.start, 'Assigning to rvalue');\n            }\n        } else if (refDestructuringErrors)\n            this.checkPatternErrors(refDestructuringErrors, true);\n        return node;\n    };\n    pp.toAssignableList = function (exprList, isBinding) {\n        let end = exprList.length;\n        for (let i = 0; i < end; i++) {\n            let elt = exprList[i];\n            if (elt)\n                this.toAssignable(elt, isBinding);\n        }\n        if (end) {\n            let last = exprList[end - 1];\n            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === 'RestElement' && last.argument.type !== 'Identifier')\n                this.unexpected(last.argument.start);\n        }\n        return exprList;\n    };\n    pp.parseSpread = function (refDestructuringErrors) {\n        let node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        return this.finishNode(node, 'SpreadElement');\n    };\n    pp.parseRestBinding = function () {\n        let node = this.startNode();\n        this.next();\n        if (this.options.ecmaVersion === 6 && this.type !== tt.name)\n            this.unexpected();\n        node.argument = this.parseBindingAtom();\n        return this.finishNode(node, 'RestElement');\n    };\n    pp.parseBindingAtom = function () {\n        if (this.options.ecmaVersion >= 6) {\n            switch (this.type) {\n            case tt.bracketL:\n                let node = this.startNode();\n                this.next();\n                node.elements = this.parseBindingList(tt.bracketR, true, true);\n                return this.finishNode(node, 'ArrayPattern');\n            case tt.braceL:\n                return this.parseObj(true);\n            }\n        }\n        return this.parseIdent();\n    };\n    pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowModifiers) {\n        let elts = [], first = true;\n        while (!this.eat(close)) {\n            if (first)\n                first = false;\n            else\n                this.expect(tt.comma);\n            if (allowEmpty && this.type === tt.comma) {\n                elts.push(null);\n            } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n                break;\n            } else if (this.type === tt.ellipsis) {\n                let rest = this.parseRestBinding();\n                this.parseBindingListItem(rest);\n                elts.push(rest);\n                if (this.type === tt.comma)\n                    this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element');\n                this.expect(close);\n                break;\n            } else {\n                elts.push(this.parseAssignableListItem(allowModifiers));\n            }\n        }\n        return elts;\n    };\n    pp.parseAssignableListItem = function (allowModifiers) {\n        let elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        return elem;\n    };\n    pp.parseBindingListItem = function (param) {\n        return param;\n    };\n    pp.parseMaybeDefault = function (startPos, startLoc, left) {\n        left = left || this.parseBindingAtom();\n        if (this.options.ecmaVersion < 6 || !this.eat(tt.eq))\n            return left;\n        let node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.right = this.parseMaybeAssign();\n        return this.finishNode(node, 'AssignmentPattern');\n    };\n    pp.checkLValSimple = function (expr, bindingType = BIND_NONE, checkClashes) {\n        const isBind = bindingType !== BIND_NONE;\n        switch (expr.type) {\n        case 'Identifier':\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n                this.raiseRecoverable(expr.start, (isBind ? 'Binding ' : 'Assigning to ') + expr.name + ' in strict mode');\n            if (isBind) {\n                if (bindingType === BIND_LEXICAL && expr.name === 'let')\n                    this.raiseRecoverable(expr.start, 'let is disallowed as a lexically bound name');\n                if (checkClashes) {\n                    if (hasOwn(checkClashes, expr.name))\n                        this.raiseRecoverable(expr.start, 'Argument name clash');\n                    checkClashes[expr.name] = true;\n                }\n                if (bindingType !== BIND_OUTSIDE)\n                    this.declareName(expr.name, bindingType, expr.start);\n            }\n            break;\n        case 'ChainExpression':\n            this.raiseRecoverable(expr.start, 'Optional chaining cannot appear in left-hand side');\n            break;\n        case 'MemberExpression':\n            if (isBind)\n                this.raiseRecoverable(expr.start, 'Binding member expression');\n            break;\n        case 'ParenthesizedExpression':\n            if (isBind)\n                this.raiseRecoverable(expr.start, 'Binding parenthesized expression');\n            return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n        default:\n            this.raise(expr.start, (isBind ? 'Binding' : 'Assigning to') + ' rvalue');\n        }\n    };\n    pp.checkLValPattern = function (expr, bindingType = BIND_NONE, checkClashes) {\n        switch (expr.type) {\n        case 'ObjectPattern':\n            for (let prop of expr.properties) {\n                this.checkLValInnerPattern(prop, bindingType, checkClashes);\n            }\n            break;\n        case 'ArrayPattern':\n            for (let elem of expr.elements) {\n                if (elem)\n                    this.checkLValInnerPattern(elem, bindingType, checkClashes);\n            }\n            break;\n        default:\n            this.checkLValSimple(expr, bindingType, checkClashes);\n        }\n    };\n    pp.checkLValInnerPattern = function (expr, bindingType = BIND_NONE, checkClashes) {\n        switch (expr.type) {\n        case 'Property':\n            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n            break;\n        case 'AssignmentPattern':\n            this.checkLValPattern(expr.left, bindingType, checkClashes);\n            break;\n        case 'RestElement':\n            this.checkLValPattern(expr.argument, bindingType, checkClashes);\n            break;\n        default:\n            this.checkLValPattern(expr, bindingType, checkClashes);\n        }\n    };\n});"]}