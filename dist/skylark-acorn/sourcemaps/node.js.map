{"version":3,"sources":["node.js"],"names":["define","m_state","m_locutil","Parser","SourceLocation","Node","[object Object]","parser","pos","loc","this","type","start","end","options","locations","directSourceFile","sourceFile","ranges","range","pp","prototype","finishNodeAt","node","startNode","startLoc","startNodeAt","finishNode","call","lastTokEnd","lastTokEndLoc","copyNode","newNode","prop"],"mappings":";;;;;;;AAAAA,QACI,UACA,aACD,SAAUC,EAASC,GAClB,aACA,MAAMC,OAACA,GAAUF,GACXG,eAACA,GAAkBF,QACnBG,EACFC,YAAYC,EAAQC,EAAKC,GACrBC,KAAKC,KAAO,GACZD,KAAKE,MAAQJ,EACbE,KAAKG,IAAM,EACPN,EAAOO,QAAQC,YACfL,KAAKD,IAAM,IAAIL,EAAeG,EAAQE,IACtCF,EAAOO,QAAQE,mBACfN,KAAKO,WAAaV,EAAOO,QAAQE,kBACjCT,EAAOO,QAAQI,SACfR,KAAKS,OACDX,EACA,KAIhB,MAAMY,EAAKjB,EAAOkB,UAOlB,SAASC,EAAaC,EAAMZ,EAAMH,EAAKC,GAOnC,OANAc,EAAKZ,KAAOA,EACZY,EAAKV,IAAML,EACPE,KAAKI,QAAQC,YACbQ,EAAKd,IAAII,IAAMJ,GACfC,KAAKI,QAAQI,SACbK,EAAKJ,MAAM,GAAKX,GACbe,EAcX,OA3BAH,EAAGI,UAAY,WACX,OAAO,IAAInB,EAAKK,KAAMA,KAAKE,MAAOF,KAAKe,WAE3CL,EAAGM,YAAc,SAAUlB,EAAKC,GAC5B,OAAO,IAAIJ,EAAKK,KAAMF,EAAKC,IAW/BW,EAAGO,WAAa,SAAUJ,EAAMZ,GAC5B,OAAOW,EAAaM,KAAKlB,KAAMa,EAAMZ,EAAMD,KAAKmB,WAAYnB,KAAKoB,gBAErEV,EAAGE,aAAe,SAAUC,EAAMZ,EAAMH,EAAKC,GACzC,OAAOa,EAAaM,KAAKlB,KAAMa,EAAMZ,EAAMH,EAAKC,IAEpDW,EAAGW,SAAW,SAAUR,GACpB,IAAIS,EAAU,IAAI3B,EAAKK,KAAMa,EAAKX,MAAOF,KAAKe,UAC9C,IAAK,IAAIQ,KAAQV,EACbS,EAAQC,GAAQV,EAAKU,GACzB,OAAOD,IAEF3B,KAAMA","file":"../node.js","sourcesContent":["define([\n    './state',\n    './locutil'\n], function (m_state, m_locutil) {\n    'use strict';\n    const {Parser} = m_state;\n    const {SourceLocation} = m_locutil;\n    class Node {\n        constructor(parser, pos, loc) {\n            this.type = '';\n            this.start = pos;\n            this.end = 0;\n            if (parser.options.locations)\n                this.loc = new SourceLocation(parser, loc);\n            if (parser.options.directSourceFile)\n                this.sourceFile = parser.options.directSourceFile;\n            if (parser.options.ranges)\n                this.range = [\n                    pos,\n                    0\n                ];\n        }\n    }\n    const pp = Parser.prototype;\n    pp.startNode = function () {\n        return new Node(this, this.start, this.startLoc);\n    };\n    pp.startNodeAt = function (pos, loc) {\n        return new Node(this, pos, loc);\n    };\n    function finishNodeAt(node, type, pos, loc) {\n        node.type = type;\n        node.end = pos;\n        if (this.options.locations)\n            node.loc.end = loc;\n        if (this.options.ranges)\n            node.range[1] = pos;\n        return node;\n    }\n    pp.finishNode = function (node, type) {\n        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n    };\n    pp.finishNodeAt = function (node, type, pos, loc) {\n        return finishNodeAt.call(this, node, type, pos, loc);\n    };\n    pp.copyNode = function (node) {\n        let newNode = new Node(this, node.start, this.startLoc);\n        for (let prop in node)\n            newNode[prop] = node[prop];\n        return newNode;\n    };\n    return { Node: Node };\n});"]}