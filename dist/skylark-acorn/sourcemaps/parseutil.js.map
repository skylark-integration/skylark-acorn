{"version":3,"sources":["parseutil.js"],"names":["define","tt","m_state","m_whitespace","Parser","lineBreak","skipWhiteSpace","pp","prototype","literal","strictDirective","start","this","options","ecmaVersion","lastIndex","exec","input","length","match","slice","spaceAfter","end","index","next","charAt","test","eat","type","isContextual","name","value","containsEsc","eatContextual","expectContextual","unexpected","canInsertSemicolon","eof","braceR","lastTokEnd","insertSemicolon","onInsertedSemicolon","lastTokEndLoc","semicolon","semi","afterTrailingComma","tokType","notNext","onTrailingComma","lastTokStart","lastTokStartLoc","expect","pos","raise","checkPatternErrors","refDestructuringErrors","isAssign","trailingComma","raiseRecoverable","parens","parenthesizedAssign","parenthesizedBind","checkExpressionErrors","andThrow","shorthandAssign","doubleProto","checkYieldAwaitInDefaultParams","yieldPos","awaitPos","isSimpleAssignTarget","expr","expression","DestructuringErrors","[object Object]"],"mappings":"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","file":"../parseutil.js","sourcesContent":["define([\n    './tokentype',\n    './state',\n    './whitespace'\n], function (tt, m_state, m_whitespace) {\n    'use strict';\n    const {Parser} = m_state;\n    const {lineBreak, skipWhiteSpace} = m_whitespace;\n    const pp = Parser.prototype;\n    const literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\n    pp.strictDirective = function (start) {\n        if (this.options.ecmaVersion < 5)\n            return false;\n        for (;;) {\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            let match = literal.exec(this.input.slice(start));\n            if (!match)\n                return false;\n            if ((match[1] || match[2]) === 'use strict') {\n                skipWhiteSpace.lastIndex = start + match[0].length;\n                let spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n                let next = this.input.charAt(end);\n                return next === ';' || next === '}' || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === '!' && this.input.charAt(end + 1) === '=');\n            }\n            start += match[0].length;\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            if (this.input[start] === ';')\n                start++;\n        }\n    };\n    pp.eat = function (type) {\n        if (this.type === type) {\n            this.next();\n            return true;\n        } else {\n            return false;\n        }\n    };\n    pp.isContextual = function (name) {\n        return this.type === tt.name && this.value === name && !this.containsEsc;\n    };\n    pp.eatContextual = function (name) {\n        if (!this.isContextual(name))\n            return false;\n        this.next();\n        return true;\n    };\n    pp.expectContextual = function (name) {\n        if (!this.eatContextual(name))\n            this.unexpected();\n    };\n    pp.canInsertSemicolon = function () {\n        return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    pp.insertSemicolon = function () {\n        if (this.canInsertSemicolon()) {\n            if (this.options.onInsertedSemicolon)\n                this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n            return true;\n        }\n    };\n    pp.semicolon = function () {\n        if (!this.eat(tt.semi) && !this.insertSemicolon())\n            this.unexpected();\n    };\n    pp.afterTrailingComma = function (tokType, notNext) {\n        if (this.type === tokType) {\n            if (this.options.onTrailingComma)\n                this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n            if (!notNext)\n                this.next();\n            return true;\n        }\n    };\n    pp.expect = function (type) {\n        this.eat(type) || this.unexpected();\n    };\n    pp.unexpected = function (pos) {\n        this.raise(pos != null ? pos : this.start, 'Unexpected token');\n    };\n    class DestructuringErrors {\n        constructor() {\n            this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n        }\n    }\n    pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {\n        if (!refDestructuringErrors)\n            return;\n        if (refDestructuringErrors.trailingComma > -1)\n            this.raiseRecoverable(refDestructuringErrors.trailingComma, 'Comma is not permitted after the rest element');\n        let parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n        if (parens > -1)\n            this.raiseRecoverable(parens, isAssign ? 'Assigning to rvalue' : 'Parenthesized pattern');\n    };\n    pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n        if (!refDestructuringErrors)\n            return false;\n        let {shorthandAssign, doubleProto} = refDestructuringErrors;\n        if (!andThrow)\n            return shorthandAssign >= 0 || doubleProto >= 0;\n        if (shorthandAssign >= 0)\n            this.raise(shorthandAssign, 'Shorthand property assignments are valid only in destructuring patterns');\n        if (doubleProto >= 0)\n            this.raiseRecoverable(doubleProto, 'Redefinition of __proto__ property');\n    };\n    pp.checkYieldAwaitInDefaultParams = function () {\n        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n            this.raise(this.yieldPos, 'Yield expression cannot be a default value');\n        if (this.awaitPos)\n            this.raise(this.awaitPos, 'Await expression cannot be a default value');\n    };\n    pp.isSimpleAssignTarget = function (expr) {\n        if (expr.type === 'ParenthesizedExpression')\n            return this.isSimpleAssignTarget(expr.expression);\n        return expr.type === 'Identifier' || expr.type === 'MemberExpression';\n    };\n    return { DestructuringErrors: DestructuringErrors };\n});"]}