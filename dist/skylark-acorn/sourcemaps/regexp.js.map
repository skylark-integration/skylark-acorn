{"version":3,"sources":["regexp.js"],"names":["define","m_identifier","m_state","UNICODE_PROPERTY_VALUES","m_util","isIdentifierStart","isIdentifierChar","Parser","hasOwn","codePointToString","pp","prototype","isSyntaxCharacter","ch","isControlLetter","validateRegExpFlags","state","validFlags","flags","u","v","i","length","flag","charAt","indexOf","this","raise","start","options","ecmaVersion","validateRegExpPattern","regexp_pattern","switchN","groupNames","pos","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","backReferenceNames","regexp_disjunction","source","eat","name","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","switchU","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","min","max","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","current","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","advance","regexp_eatGroupName","push","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","forceU","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","n","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","isDecimalDigit","lookahead","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","isHexDigit","hexToInt","isOctalDigit","isCharacterClassEscape","negate","result","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","value","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","unicodeProperties","nonBinary","test","binary","switchV","binaryOfStrings","regexp_classContents","regexp_classSetExpression","regexp_nonEmptyClassRanges","regexp_eatClassAtom","left","right","regexp_eatClassEscape","regexp_eatClassControlLetter","subResult","regexp_eatClassSetRange","regexp_eatClassSetOperand","eatChars","regexp_eatClassSetCharacter","regexp_eatClassStringDisjunction","regexp_eatNestedClass","regexp_classStringDisjunctionContents","regexp_classString","count","regexp_eatClassSetReservedPunctuator","isClassSetReservedDoublePunctuatorCharacter","isClassSetSyntaxCharacter","isClassSetReservedPunctuator","regexp_eatOctalDigit","n1","n2","RegExpValidationState","[object Object]","parser","pattern","unicodeSets","unicode","message","raiseRecoverable","s","l","c","charCodeAt","next","at","nextIndex","chs"],"mappings":"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","file":"../regexp.js","sourcesContent":["define([\n    './identifier',\n    './state',\n    './unicode-property-data',\n    './util'\n], function (m_identifier, m_state, UNICODE_PROPERTY_VALUES, m_util) {\n    'use strict';\n    const {isIdentifierStart, isIdentifierChar} = m_identifier;\n    const {Parser} = m_state;\n    const {hasOwn, codePointToString} = m_util;\n    const pp = Parser.prototype;\n    class RegExpValidationState {\n        constructor(parser) {\n            this.parser = parser;\n            this.validFlags = `gim${ parser.options.ecmaVersion >= 6 ? 'uy' : '' }${ parser.options.ecmaVersion >= 9 ? 's' : '' }${ parser.options.ecmaVersion >= 13 ? 'd' : '' }${ parser.options.ecmaVersion >= 15 ? 'v' : '' }`;\n            this.unicodeProperties = UNICODE_PROPERTY_VALUES[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n            this.source = '';\n            this.flags = '';\n            this.start = 0;\n            this.switchU = false;\n            this.switchV = false;\n            this.switchN = false;\n            this.pos = 0;\n            this.lastIntValue = 0;\n            this.lastStringValue = '';\n            this.lastAssertionIsQuantifiable = false;\n            this.numCapturingParens = 0;\n            this.maxBackReference = 0;\n            this.groupNames = [];\n            this.backReferenceNames = [];\n        }\n        reset(start, pattern, flags) {\n            const unicodeSets = flags.indexOf('v') !== -1;\n            const unicode = flags.indexOf('u') !== -1;\n            this.start = start | 0;\n            this.source = pattern + '';\n            this.flags = flags;\n            if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n                this.switchU = true;\n                this.switchV = true;\n                this.switchN = true;\n            } else {\n                this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n                this.switchV = false;\n                this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n            }\n        }\n        raise(message) {\n            this.parser.raiseRecoverable(this.start, `Invalid regular expression: /${ this.source }/: ${ message }`);\n        }\n        at(i, forceU = false) {\n            const s = this.source;\n            const l = s.length;\n            if (i >= l) {\n                return -1;\n            }\n            const c = s.charCodeAt(i);\n            if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {\n                return c;\n            }\n            const next = s.charCodeAt(i + 1);\n            return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;\n        }\n        nextIndex(i, forceU = false) {\n            const s = this.source;\n            const l = s.length;\n            if (i >= l) {\n                return l;\n            }\n            let c = s.charCodeAt(i), next;\n            if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {\n                return i + 1;\n            }\n            return i + 2;\n        }\n        current(forceU = false) {\n            return this.at(this.pos, forceU);\n        }\n        lookahead(forceU = false) {\n            return this.at(this.nextIndex(this.pos, forceU), forceU);\n        }\n        advance(forceU = false) {\n            this.pos = this.nextIndex(this.pos, forceU);\n        }\n        eat(ch, forceU = false) {\n            if (this.current(forceU) === ch) {\n                this.advance(forceU);\n                return true;\n            }\n            return false;\n        }\n        eatChars(chs, forceU = false) {\n            let pos = this.pos;\n            for (const ch of chs) {\n                const current = this.at(pos, forceU);\n                if (current === -1 || current !== ch) {\n                    return false;\n                }\n                pos = this.nextIndex(pos, forceU);\n            }\n            this.pos = pos;\n            return true;\n        }\n    }\n    pp.validateRegExpFlags = function (state) {\n        const validFlags = state.validFlags;\n        const flags = state.flags;\n        let u = false;\n        let v = false;\n        for (let i = 0; i < flags.length; i++) {\n            const flag = flags.charAt(i);\n            if (validFlags.indexOf(flag) === -1) {\n                this.raise(state.start, 'Invalid regular expression flag');\n            }\n            if (flags.indexOf(flag, i + 1) > -1) {\n                this.raise(state.start, 'Duplicate regular expression flag');\n            }\n            if (flag === 'u')\n                u = true;\n            if (flag === 'v')\n                v = true;\n        }\n        if (this.options.ecmaVersion >= 15 && u && v) {\n            this.raise(state.start, 'Invalid regular expression flag');\n        }\n    };\n    pp.validateRegExpPattern = function (state) {\n        this.regexp_pattern(state);\n        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n            state.switchN = true;\n            this.regexp_pattern(state);\n        }\n    };\n    pp.regexp_pattern = function (state) {\n        state.pos = 0;\n        state.lastIntValue = 0;\n        state.lastStringValue = '';\n        state.lastAssertionIsQuantifiable = false;\n        state.numCapturingParens = 0;\n        state.maxBackReference = 0;\n        state.groupNames.length = 0;\n        state.backReferenceNames.length = 0;\n        this.regexp_disjunction(state);\n        if (state.pos !== state.source.length) {\n            if (state.eat(41)) {\n                state.raise(\"Unmatched ')'\");\n            }\n            if (state.eat(93) || state.eat(125)) {\n                state.raise('Lone quantifier brackets');\n            }\n        }\n        if (state.maxBackReference > state.numCapturingParens) {\n            state.raise('Invalid escape');\n        }\n        for (const name of state.backReferenceNames) {\n            if (state.groupNames.indexOf(name) === -1) {\n                state.raise('Invalid named capture referenced');\n            }\n        }\n    };\n    pp.regexp_disjunction = function (state) {\n        this.regexp_alternative(state);\n        while (state.eat(124)) {\n            this.regexp_alternative(state);\n        }\n        if (this.regexp_eatQuantifier(state, true)) {\n            state.raise('Nothing to repeat');\n        }\n        if (state.eat(123)) {\n            state.raise('Lone quantifier brackets');\n        }\n    };\n    pp.regexp_alternative = function (state) {\n        while (state.pos < state.source.length && this.regexp_eatTerm(state));\n    };\n    pp.regexp_eatTerm = function (state) {\n        if (this.regexp_eatAssertion(state)) {\n            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n                if (state.switchU) {\n                    state.raise('Invalid quantifier');\n                }\n            }\n            return true;\n        }\n        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n            this.regexp_eatQuantifier(state);\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatAssertion = function (state) {\n        const start = state.pos;\n        state.lastAssertionIsQuantifiable = false;\n        if (state.eat(94) || state.eat(36)) {\n            return true;\n        }\n        if (state.eat(92)) {\n            if (state.eat(66) || state.eat(98)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        if (state.eat(40) && state.eat(63)) {\n            let lookbehind = false;\n            if (this.options.ecmaVersion >= 9) {\n                lookbehind = state.eat(60);\n            }\n            if (state.eat(61) || state.eat(33)) {\n                this.regexp_disjunction(state);\n                if (!state.eat(41)) {\n                    state.raise('Unterminated group');\n                }\n                state.lastAssertionIsQuantifiable = !lookbehind;\n                return true;\n            }\n        }\n        state.pos = start;\n        return false;\n    };\n    pp.regexp_eatQuantifier = function (state, noError = false) {\n        if (this.regexp_eatQuantifierPrefix(state, noError)) {\n            state.eat(63);\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatQuantifierPrefix = function (state, noError) {\n        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);\n    };\n    pp.regexp_eatBracedQuantifier = function (state, noError) {\n        const start = state.pos;\n        if (state.eat(123)) {\n            let min = 0, max = -1;\n            if (this.regexp_eatDecimalDigits(state)) {\n                min = state.lastIntValue;\n                if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {\n                    max = state.lastIntValue;\n                }\n                if (state.eat(125)) {\n                    if (max !== -1 && max < min && !noError) {\n                        state.raise('numbers out of order in {} quantifier');\n                    }\n                    return true;\n                }\n            }\n            if (state.switchU && !noError) {\n                state.raise('Incomplete quantifier');\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp.regexp_eatAtom = function (state) {\n        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n    };\n    pp.regexp_eatReverseSolidusAtomEscape = function (state) {\n        const start = state.pos;\n        if (state.eat(92)) {\n            if (this.regexp_eatAtomEscape(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp.regexp_eatUncapturingGroup = function (state) {\n        const start = state.pos;\n        if (state.eat(40)) {\n            if (state.eat(63) && state.eat(58)) {\n                this.regexp_disjunction(state);\n                if (state.eat(41)) {\n                    return true;\n                }\n                state.raise('Unterminated group');\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp.regexp_eatCapturingGroup = function (state) {\n        if (state.eat(40)) {\n            if (this.options.ecmaVersion >= 9) {\n                this.regexp_groupSpecifier(state);\n            } else if (state.current() === 63) {\n                state.raise('Invalid group');\n            }\n            this.regexp_disjunction(state);\n            if (state.eat(41)) {\n                state.numCapturingParens += 1;\n                return true;\n            }\n            state.raise('Unterminated group');\n        }\n        return false;\n    };\n    pp.regexp_eatExtendedAtom = function (state) {\n        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n    };\n    pp.regexp_eatInvalidBracedQuantifier = function (state) {\n        if (this.regexp_eatBracedQuantifier(state, true)) {\n            state.raise('Nothing to repeat');\n        }\n        return false;\n    };\n    pp.regexp_eatSyntaxCharacter = function (state) {\n        const ch = state.current();\n        if (isSyntaxCharacter(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isSyntaxCharacter(ch) {\n        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;\n    }\n    pp.regexp_eatPatternCharacters = function (state) {\n        const start = state.pos;\n        let ch = 0;\n        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    pp.regexp_eatExtendedPatternCharacter = function (state) {\n        const ch = state.current();\n        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_groupSpecifier = function (state) {\n        if (state.eat(63)) {\n            if (this.regexp_eatGroupName(state)) {\n                if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n                    state.raise('Duplicate capture group name');\n                }\n                state.groupNames.push(state.lastStringValue);\n                return;\n            }\n            state.raise('Invalid group');\n        }\n    };\n    pp.regexp_eatGroupName = function (state) {\n        state.lastStringValue = '';\n        if (state.eat(60)) {\n            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {\n                return true;\n            }\n            state.raise('Invalid capture group name');\n        }\n        return false;\n    };\n    pp.regexp_eatRegExpIdentifierName = function (state) {\n        state.lastStringValue = '';\n        if (this.regexp_eatRegExpIdentifierStart(state)) {\n            state.lastStringValue += codePointToString(state.lastIntValue);\n            while (this.regexp_eatRegExpIdentifierPart(state)) {\n                state.lastStringValue += codePointToString(state.lastIntValue);\n            }\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatRegExpIdentifierStart = function (state) {\n        const start = state.pos;\n        const forceU = this.options.ecmaVersion >= 11;\n        let ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierStart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierStart(ch) {\n        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;\n    }\n    pp.regexp_eatRegExpIdentifierPart = function (state) {\n        const start = state.pos;\n        const forceU = this.options.ecmaVersion >= 11;\n        let ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierPart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierPart(ch) {\n        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;\n    }\n    pp.regexp_eatAtomEscape = function (state) {\n        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n            return true;\n        }\n        if (state.switchU) {\n            if (state.current() === 99) {\n                state.raise('Invalid unicode escape');\n            }\n            state.raise('Invalid escape');\n        }\n        return false;\n    };\n    pp.regexp_eatBackReference = function (state) {\n        const start = state.pos;\n        if (this.regexp_eatDecimalEscape(state)) {\n            const n = state.lastIntValue;\n            if (state.switchU) {\n                if (n > state.maxBackReference) {\n                    state.maxBackReference = n;\n                }\n                return true;\n            }\n            if (n <= state.numCapturingParens) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp.regexp_eatKGroupName = function (state) {\n        if (state.eat(107)) {\n            if (this.regexp_eatGroupName(state)) {\n                state.backReferenceNames.push(state.lastStringValue);\n                return true;\n            }\n            state.raise('Invalid named reference');\n        }\n        return false;\n    };\n    pp.regexp_eatCharacterEscape = function (state) {\n        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n    };\n    pp.regexp_eatCControlLetter = function (state) {\n        const start = state.pos;\n        if (state.eat(99)) {\n            if (this.regexp_eatControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp.regexp_eatZero = function (state) {\n        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {\n            state.lastIntValue = 0;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatControlEscape = function (state) {\n        const ch = state.current();\n        if (ch === 116) {\n            state.lastIntValue = 9;\n            state.advance();\n            return true;\n        }\n        if (ch === 110) {\n            state.lastIntValue = 10;\n            state.advance();\n            return true;\n        }\n        if (ch === 118) {\n            state.lastIntValue = 11;\n            state.advance();\n            return true;\n        }\n        if (ch === 102) {\n            state.lastIntValue = 12;\n            state.advance();\n            return true;\n        }\n        if (ch === 114) {\n            state.lastIntValue = 13;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatControlLetter = function (state) {\n        const ch = state.current();\n        if (isControlLetter(ch)) {\n            state.lastIntValue = ch % 32;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isControlLetter(ch) {\n        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;\n    }\n    pp.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU = false) {\n        const start = state.pos;\n        const switchU = forceU || state.switchU;\n        if (state.eat(117)) {\n            if (this.regexp_eatFixedHexDigits(state, 4)) {\n                const lead = state.lastIntValue;\n                if (switchU && lead >= 55296 && lead <= 56319) {\n                    const leadSurrogateEnd = state.pos;\n                    if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {\n                        const trail = state.lastIntValue;\n                        if (trail >= 56320 && trail <= 57343) {\n                            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;\n                            return true;\n                        }\n                    }\n                    state.pos = leadSurrogateEnd;\n                    state.lastIntValue = lead;\n                }\n                return true;\n            }\n            if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {\n                return true;\n            }\n            if (switchU) {\n                state.raise('Invalid unicode escape');\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    function isValidUnicode(ch) {\n        return ch >= 0 && ch <= 1114111;\n    }\n    pp.regexp_eatIdentityEscape = function (state) {\n        if (state.switchU) {\n            if (this.regexp_eatSyntaxCharacter(state)) {\n                return true;\n            }\n            if (state.eat(47)) {\n                state.lastIntValue = 47;\n                return true;\n            }\n            return false;\n        }\n        const ch = state.current();\n        if (ch !== 99 && (!state.switchN || ch !== 107)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatDecimalEscape = function (state) {\n        state.lastIntValue = 0;\n        let ch = state.current();\n        if (ch >= 49 && ch <= 57) {\n            do {\n                state.lastIntValue = 10 * state.lastIntValue + (ch - 48);\n                state.advance();\n            } while ((ch = state.current()) >= 48 && ch <= 57);\n            return true;\n        }\n        return false;\n    };\n    const CharSetNone = 0;\n    const CharSetOk = 1;\n    const CharSetString = 2;\n    pp.regexp_eatCharacterClassEscape = function (state) {\n        const ch = state.current();\n        if (isCharacterClassEscape(ch)) {\n            state.lastIntValue = -1;\n            state.advance();\n            return CharSetOk;\n        }\n        let negate = false;\n        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {\n            state.lastIntValue = -1;\n            state.advance();\n            let result;\n            if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {\n                if (negate && result === CharSetString)\n                    state.raise('Invalid property name');\n                return result;\n            }\n            state.raise('Invalid property name');\n        }\n        return CharSetNone;\n    };\n    function isCharacterClassEscape(ch) {\n        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;\n    }\n    pp.regexp_eatUnicodePropertyValueExpression = function (state) {\n        const start = state.pos;\n        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {\n            const name = state.lastStringValue;\n            if (this.regexp_eatUnicodePropertyValue(state)) {\n                const value = state.lastStringValue;\n                this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n                return CharSetOk;\n            }\n        }\n        state.pos = start;\n        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n            const nameOrValue = state.lastStringValue;\n            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n        }\n        return CharSetNone;\n    };\n    pp.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {\n        if (!hasOwn(state.unicodeProperties.nonBinary, name))\n            state.raise('Invalid property name');\n        if (!state.unicodeProperties.nonBinary[name].test(value))\n            state.raise('Invalid property value');\n    };\n    pp.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {\n        if (state.unicodeProperties.binary.test(nameOrValue))\n            return CharSetOk;\n        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue))\n            return CharSetString;\n        state.raise('Invalid property name');\n    };\n    pp.regexp_eatUnicodePropertyName = function (state) {\n        let ch = 0;\n        state.lastStringValue = '';\n        while (isUnicodePropertyNameCharacter(ch = state.current())) {\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== '';\n    };\n    function isUnicodePropertyNameCharacter(ch) {\n        return isControlLetter(ch) || ch === 95;\n    }\n    pp.regexp_eatUnicodePropertyValue = function (state) {\n        let ch = 0;\n        state.lastStringValue = '';\n        while (isUnicodePropertyValueCharacter(ch = state.current())) {\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== '';\n    };\n    function isUnicodePropertyValueCharacter(ch) {\n        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n    }\n    pp.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {\n        return this.regexp_eatUnicodePropertyValue(state);\n    };\n    pp.regexp_eatCharacterClass = function (state) {\n        if (state.eat(91)) {\n            const negate = state.eat(94);\n            const result = this.regexp_classContents(state);\n            if (!state.eat(93))\n                state.raise('Unterminated character class');\n            if (negate && result === CharSetString)\n                state.raise('Negated character class may contain strings');\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_classContents = function (state) {\n        if (state.current() === 93)\n            return CharSetOk;\n        if (state.switchV)\n            return this.regexp_classSetExpression(state);\n        this.regexp_nonEmptyClassRanges(state);\n        return CharSetOk;\n    };\n    pp.regexp_nonEmptyClassRanges = function (state) {\n        while (this.regexp_eatClassAtom(state)) {\n            const left = state.lastIntValue;\n            if (state.eat(45) && this.regexp_eatClassAtom(state)) {\n                const right = state.lastIntValue;\n                if (state.switchU && (left === -1 || right === -1)) {\n                    state.raise('Invalid character class');\n                }\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise('Range out of order in character class');\n                }\n            }\n        }\n    };\n    pp.regexp_eatClassAtom = function (state) {\n        const start = state.pos;\n        if (state.eat(92)) {\n            if (this.regexp_eatClassEscape(state)) {\n                return true;\n            }\n            if (state.switchU) {\n                const ch = state.current();\n                if (ch === 99 || isOctalDigit(ch)) {\n                    state.raise('Invalid class escape');\n                }\n                state.raise('Invalid escape');\n            }\n            state.pos = start;\n        }\n        const ch = state.current();\n        if (ch !== 93) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatClassEscape = function (state) {\n        const start = state.pos;\n        if (state.eat(98)) {\n            state.lastIntValue = 8;\n            return true;\n        }\n        if (state.switchU && state.eat(45)) {\n            state.lastIntValue = 45;\n            return true;\n        }\n        if (!state.switchU && state.eat(99)) {\n            if (this.regexp_eatClassControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n    };\n    pp.regexp_classSetExpression = function (state) {\n        let result = CharSetOk, subResult;\n        if (this.regexp_eatClassSetRange(state)) {\n        } else if (subResult = this.regexp_eatClassSetOperand(state)) {\n            if (subResult === CharSetString)\n                result = CharSetString;\n            const start = state.pos;\n            while (state.eatChars([\n                    38,\n                    38\n                ])) {\n                if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {\n                    if (subResult !== CharSetString)\n                        result = CharSetOk;\n                    continue;\n                }\n                state.raise('Invalid character in character class');\n            }\n            if (start !== state.pos)\n                return result;\n            while (state.eatChars([\n                    45,\n                    45\n                ])) {\n                if (this.regexp_eatClassSetOperand(state))\n                    continue;\n                state.raise('Invalid character in character class');\n            }\n            if (start !== state.pos)\n                return result;\n        } else {\n            state.raise('Invalid character in character class');\n        }\n        for (;;) {\n            if (this.regexp_eatClassSetRange(state))\n                continue;\n            subResult = this.regexp_eatClassSetOperand(state);\n            if (!subResult)\n                return result;\n            if (subResult === CharSetString)\n                result = CharSetString;\n        }\n    };\n    pp.regexp_eatClassSetRange = function (state) {\n        const start = state.pos;\n        if (this.regexp_eatClassSetCharacter(state)) {\n            const left = state.lastIntValue;\n            if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {\n                const right = state.lastIntValue;\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise('Range out of order in character class');\n                }\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp.regexp_eatClassSetOperand = function (state) {\n        if (this.regexp_eatClassSetCharacter(state))\n            return CharSetOk;\n        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n    };\n    pp.regexp_eatNestedClass = function (state) {\n        const start = state.pos;\n        if (state.eat(91)) {\n            const negate = state.eat(94);\n            const result = this.regexp_classContents(state);\n            if (state.eat(93)) {\n                if (negate && result === CharSetString) {\n                    state.raise('Negated character class may contain strings');\n                }\n                return result;\n            }\n            state.pos = start;\n        }\n        if (state.eat(92)) {\n            const result = this.regexp_eatCharacterClassEscape(state);\n            if (result) {\n                return result;\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    pp.regexp_eatClassStringDisjunction = function (state) {\n        const start = state.pos;\n        if (state.eatChars([\n                92,\n                113\n            ])) {\n            if (state.eat(123)) {\n                const result = this.regexp_classStringDisjunctionContents(state);\n                if (state.eat(125)) {\n                    return result;\n                }\n            } else {\n                state.raise('Invalid escape');\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    pp.regexp_classStringDisjunctionContents = function (state) {\n        let result = this.regexp_classString(state);\n        while (state.eat(124)) {\n            if (this.regexp_classString(state) === CharSetString)\n                result = CharSetString;\n        }\n        return result;\n    };\n    pp.regexp_classString = function (state) {\n        let count = 0;\n        while (this.regexp_eatClassSetCharacter(state))\n            count++;\n        return count === 1 ? CharSetOk : CharSetString;\n    };\n    pp.regexp_eatClassSetCharacter = function (state) {\n        const start = state.pos;\n        if (state.eat(92)) {\n            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {\n                return true;\n            }\n            if (state.eat(98)) {\n                state.lastIntValue = 8;\n                return true;\n            }\n            state.pos = start;\n            return false;\n        }\n        const ch = state.current();\n        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch))\n            return false;\n        if (isClassSetSyntaxCharacter(ch))\n            return false;\n        state.advance();\n        state.lastIntValue = ch;\n        return true;\n    };\n    function isClassSetReservedDoublePunctuatorCharacter(ch) {\n        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;\n    }\n    function isClassSetSyntaxCharacter(ch) {\n        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;\n    }\n    pp.regexp_eatClassSetReservedPunctuator = function (state) {\n        const ch = state.current();\n        if (isClassSetReservedPunctuator(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isClassSetReservedPunctuator(ch) {\n        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;\n    }\n    pp.regexp_eatClassControlLetter = function (state) {\n        const ch = state.current();\n        if (isDecimalDigit(ch) || ch === 95) {\n            state.lastIntValue = ch % 32;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatHexEscapeSequence = function (state) {\n        const start = state.pos;\n        if (state.eat(120)) {\n            if (this.regexp_eatFixedHexDigits(state, 2)) {\n                return true;\n            }\n            if (state.switchU) {\n                state.raise('Invalid escape');\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp.regexp_eatDecimalDigits = function (state) {\n        const start = state.pos;\n        let ch = 0;\n        state.lastIntValue = 0;\n        while (isDecimalDigit(ch = state.current())) {\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isDecimalDigit(ch) {\n        return ch >= 48 && ch <= 57;\n    }\n    pp.regexp_eatHexDigits = function (state) {\n        const start = state.pos;\n        let ch = 0;\n        state.lastIntValue = 0;\n        while (isHexDigit(ch = state.current())) {\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isHexDigit(ch) {\n        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;\n    }\n    function hexToInt(ch) {\n        if (ch >= 65 && ch <= 70) {\n            return 10 + (ch - 65);\n        }\n        if (ch >= 97 && ch <= 102) {\n            return 10 + (ch - 97);\n        }\n        return ch - 48;\n    }\n    pp.regexp_eatLegacyOctalEscapeSequence = function (state) {\n        if (this.regexp_eatOctalDigit(state)) {\n            const n1 = state.lastIntValue;\n            if (this.regexp_eatOctalDigit(state)) {\n                const n2 = state.lastIntValue;\n                if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n                    state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n                } else {\n                    state.lastIntValue = n1 * 8 + n2;\n                }\n            } else {\n                state.lastIntValue = n1;\n            }\n            return true;\n        }\n        return false;\n    };\n    pp.regexp_eatOctalDigit = function (state) {\n        const ch = state.current();\n        if (isOctalDigit(ch)) {\n            state.lastIntValue = ch - 48;\n            state.advance();\n            return true;\n        }\n        state.lastIntValue = 0;\n        return false;\n    };\n    function isOctalDigit(ch) {\n        return ch >= 48 && ch <= 55;\n    }\n    pp.regexp_eatFixedHexDigits = function (state, length) {\n        const start = state.pos;\n        state.lastIntValue = 0;\n        for (let i = 0; i < length; ++i) {\n            const ch = state.current();\n            if (!isHexDigit(ch)) {\n                state.pos = start;\n                return false;\n            }\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return true;\n    };\n    return { RegExpValidationState: RegExpValidationState };\n});"]}