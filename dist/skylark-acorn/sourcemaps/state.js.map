{"version":3,"sources":["state.js"],"names":["define","m_identifier","tt","m_whitespace","m_options","m_util","m_scopeflags","reservedWords","keywords","lineBreak","getOptions","wordsRegexp","SCOPE_TOP","SCOPE_FUNCTION","SCOPE_ASYNC","SCOPE_GENERATOR","SCOPE_SUPER","SCOPE_DIRECT_SUPER","SCOPE_CLASS_STATIC_BLOCK","Parser","[object Object]","options","input","startPos","this","sourceFile","ecmaVersion","sourceType","reserved","allowReserved","reservedStrict","strict","reservedWordsStrict","reservedWordsStrictBind","strictBind","String","containsEsc","pos","lineStart","lastIndexOf","curLine","slice","split","length","type","eof","value","start","end","startLoc","endLoc","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","potentialArrowInForAwait","yieldPos","awaitPos","awaitIdentPos","labels","undefinedExports","Object","create","allowHashBang","skipLineComment","scopeStack","enterScope","regexpState","privateNameStack","node","program","startNode","nextToken","parseTopLevel","inFunction","currentVarScope","flags","inGenerator","inClassFieldInit","inAsync","canAwait","i","scope","allowAwaitOutsideFunction","allowSuper","currentThisScope","allowSuperOutsideMethod","allowDirectSuper","treatFunctionsAsVar","treatFunctionsAsVarInScope","currentScope","allowNewDotTarget","inClassStaticBlock","plugins","cls","parse","parser","parseExpression"],"mappings":"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","file":"../state.js","sourcesContent":["define([\n    './identifier',\n    './tokentype',\n    './whitespace',\n    './options',\n    './util',\n    './scopeflags'\n], function (m_identifier, tt, m_whitespace, m_options, m_util, m_scopeflags) {\n    'use strict';\n    const {reservedWords, keywords} = m_identifier;\n    const {lineBreak} = m_whitespace;\n    const {getOptions} = m_options;\n    const {wordsRegexp} = m_util;\n    const {SCOPE_TOP, SCOPE_FUNCTION, SCOPE_ASYNC, SCOPE_GENERATOR, SCOPE_SUPER, SCOPE_DIRECT_SUPER, SCOPE_CLASS_STATIC_BLOCK} = m_scopeflags;\n    class Parser {\n        constructor(options, input, startPos) {\n            this.options = options = getOptions(options);\n            this.sourceFile = options.sourceFile;\n            this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === 'module' ? '5module' : 5]);\n            let reserved = '';\n            if (options.allowReserved !== true) {\n                reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n                if (options.sourceType === 'module')\n                    reserved += ' await';\n            }\n            this.reservedWords = wordsRegexp(reserved);\n            let reservedStrict = (reserved ? reserved + ' ' : '') + reservedWords.strict;\n            this.reservedWordsStrict = wordsRegexp(reservedStrict);\n            this.reservedWordsStrictBind = wordsRegexp(reservedStrict + ' ' + reservedWords.strictBind);\n            this.input = String(input);\n            this.containsEsc = false;\n            if (startPos) {\n                this.pos = startPos;\n                this.lineStart = this.input.lastIndexOf('\\n', startPos - 1) + 1;\n                this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n            } else {\n                this.pos = this.lineStart = 0;\n                this.curLine = 1;\n            }\n            this.type = tt.eof;\n            this.value = null;\n            this.start = this.end = this.pos;\n            this.startLoc = this.endLoc = this.curPosition();\n            this.lastTokEndLoc = this.lastTokStartLoc = null;\n            this.lastTokStart = this.lastTokEnd = this.pos;\n            this.context = this.initialContext();\n            this.exprAllowed = true;\n            this.inModule = options.sourceType === 'module';\n            this.strict = this.inModule || this.strictDirective(this.pos);\n            this.potentialArrowAt = -1;\n            this.potentialArrowInForAwait = false;\n            this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n            this.labels = [];\n            this.undefinedExports = Object.create(null);\n            if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n                this.skipLineComment(2);\n            this.scopeStack = [];\n            this.enterScope(SCOPE_TOP);\n            this.regexpState = null;\n            this.privateNameStack = [];\n        }\n        parse() {\n            let node = this.options.program || this.startNode();\n            this.nextToken();\n            return this.parseTopLevel(node);\n        }\n        get inFunction() {\n            return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n        }\n        get inGenerator() {\n            return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;\n        }\n        get inAsync() {\n            return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;\n        }\n        get canAwait() {\n            for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n                let scope = this.scopeStack[i];\n                if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK)\n                    return false;\n                if (scope.flags & SCOPE_FUNCTION)\n                    return (scope.flags & SCOPE_ASYNC) > 0;\n            }\n            return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n        }\n        get allowSuper() {\n            const {flags, inClassFieldInit} = this.currentThisScope();\n            return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;\n        }\n        get allowDirectSuper() {\n            return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n        }\n        get treatFunctionsAsVar() {\n            return this.treatFunctionsAsVarInScope(this.currentScope());\n        }\n        get allowNewDotTarget() {\n            const {flags, inClassFieldInit} = this.currentThisScope();\n            return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;\n        }\n        get inClassStaticBlock() {\n            return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;\n        }\n        static extend(...plugins) {\n            let cls = this;\n            for (let i = 0; i < plugins.length; i++)\n                cls = plugins[i](cls);\n            return cls;\n        }\n        static parse(input, options) {\n            return new this(options, input).parse();\n        }\n        static parseExpressionAt(input, pos, options) {\n            let parser = new this(options, input, pos);\n            parser.nextToken();\n            return parser.parseExpression();\n        }\n        static tokenizer(input, options) {\n            return new this(options, input);\n        }\n    }\n    return { Parser: Parser };\n});"]}