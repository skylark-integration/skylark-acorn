{"version":3,"sources":["statement.js"],"names":["define","tt","m_state","m_whitespace","m_identifier","m_util","m_parseutil","m_scopeflags","Parser","lineBreak","skipWhiteSpace","isIdentifierStart","isIdentifierChar","keywordRelationalOperator","hasOwn","loneSurrogate","DestructuringErrors","functionFlags","SCOPE_SIMPLE_CATCH","BIND_SIMPLE_CATCH","BIND_LEXICAL","BIND_VAR","BIND_FUNCTION","SCOPE_CLASS_STATIC_BLOCK","SCOPE_SUPER","pp","prototype","parseTopLevel","node","exports","Object","create","body","this","type","eof","stmt","parseStatement","push","inModule","name","keys","undefinedExports","raiseRecoverable","start","adaptDirectivePrologue","next","sourceType","options","finishNode","loopLabel","kind","switchLabel","isLet","context","ecmaVersion","isContextual","lastIndex","pos","skip","exec","input","length","nextCh","charCodeAt","ident","slice","test","isAsyncFunction","after","topLevel","starttype","startNode","_var","_break","_continue","parseBreakContinueStatement","keyword","_debugger","parseDebuggerStatement","_do","parseDoStatement","_for","parseForStatement","_function","strict","unexpected","parseFunctionStatement","_class","parseClass","_if","parseIfStatement","_return","parseReturnStatement","_switch","parseSwitchStatement","_throw","parseThrowStatement","_try","parseTryStatement","_const","value","parseVarStatement","_while","parseWhileStatement","_with","parseWithStatement","braceL","parseBlock","semi","parseEmptyStatement","_export","_import","parseExpressionStatement","parseExpression","allowImportExportEverywhere","raise","parseImport","parseExport","maybeName","expr","eat","colon","parseLabeledStatement","isBreak","insertSemicolon","label","parseIdent","semicolon","i","labels","lab","pop","expect","parseParenExpression","awaitAt","canAwait","eatContextual","lastTokStart","enterScope","parenL","parseFor","init","parseVar","_in","declarations","await","parseForIn","startsWithLet","isForOf","refDestructuringErrors","toAssignable","checkLValPattern","checkExpressionErrors","isAsync","declarationPosition","parseFunction","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","consequent","alternate","_else","inFunction","allowReturnOutsideFunction","argument","cur","discriminant","cases","sawDefault","braceR","_case","_default","isCase","exitScope","lastTokEnd","empty","parseCatchClauseParam","param","parseBindingAtom","simple","parenR","block","handler","_catch","clause","finalizer","_finally","allowMissingInitializer","object","isLoop","statementStart","indexOf","expression","createNewLexicalScope","exitStrict","update","isForIn","id","left","right","parseMaybeAssign","isFor","decl","parseVarId","eq","comma","isPrivateNameConflicted","privateNameMap","element","key","curr","static","checkKeyName","computed","statement","allowExpressionBody","forInit","initFunction","star","generator","async","checkLValSimple","treatFunctionsAsVar","oldYieldPos","yieldPos","oldAwaitPos","awaitPos","oldAwaitIdentPos","awaitIdentPos","parseFunctionParams","parseFunctionBody","params","parseBindingList","checkYieldAwaitInDefaultParams","isStatement","oldStrict","parseClassId","parseClassSuper","enterClassBody","classBody","hadConstructor","parseClassElement","superClass","exitClassBody","constructorAllowsSuper","keyName","isGenerator","isStatic","parseClassStaticBlock","isClassElementNameStart","canInsertSemicolon","lastValue","startNodeAt","lastTokStartLoc","parseClassElementName","isConstructor","allowsDirectSuper","parseClassMethod","parseClassField","privateId","num","string","bracketL","parsePrivateIdent","parsePropertyName","method","parseMethod","field","scope","currentThisScope","inClassFieldInit","oldLabels","_extends","parseExprSubscripts","declared","used","privateNameStack","checkPrivateFields","len","parent","parseExportAllDeclaration","exported","parseModuleExportName","checkExport","expectContextual","source","parseExprAtom","declaration","parseExportDefaultDeclaration","shouldParseExportStatement","parseExportDeclaration","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkLocalExport","fNode","cNode","checkPatternExport","pat","prop","properties","elt","elements","decls","parseExportSpecifier","nodes","first","afterTrailingComma","parseImportSpecifiers","parseImportSpecifier","imported","parseImportDefaultSpecifier","parseImportNamespaceSpecifier","stringLiteral","parseLiteral","statements","isDirectiveCandidate","directive","raw"],"mappings":"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","file":"../statement.js","sourcesContent":["define([\n    './tokentype',\n    './state',\n    './whitespace',\n    './identifier',\n    './util',\n    './parseutil',\n    './scopeflags'\n], function (tt, m_state, m_whitespace, m_identifier, m_util, m_parseutil, m_scopeflags) {\n    'use strict';\n    const {Parser} = m_state;\n    const {lineBreak, skipWhiteSpace} = m_whitespace;\n    const {isIdentifierStart, isIdentifierChar, keywordRelationalOperator} = m_identifier;\n    const {hasOwn, loneSurrogate} = m_util;\n    const {DestructuringErrors} = m_parseutil;\n    const {functionFlags, SCOPE_SIMPLE_CATCH, BIND_SIMPLE_CATCH, BIND_LEXICAL, BIND_VAR, BIND_FUNCTION, SCOPE_CLASS_STATIC_BLOCK, SCOPE_SUPER} = m_scopeflags;\n    const pp = Parser.prototype;\n    pp.parseTopLevel = function (node) {\n        let exports = Object.create(null);\n        if (!node.body)\n            node.body = [];\n        while (this.type !== tt.eof) {\n            let stmt = this.parseStatement(null, true, exports);\n            node.body.push(stmt);\n        }\n        if (this.inModule)\n            for (let name of Object.keys(this.undefinedExports))\n                this.raiseRecoverable(this.undefinedExports[name].start, `Export '${ name }' is not defined`);\n        this.adaptDirectivePrologue(node.body);\n        this.next();\n        node.sourceType = this.options.sourceType;\n        return this.finishNode(node, 'Program');\n    };\n    const loopLabel = { kind: 'loop' }, switchLabel = { kind: 'switch' };\n    pp.isLet = function (context) {\n        if (this.options.ecmaVersion < 6 || !this.isContextual('let'))\n            return false;\n        skipWhiteSpace.lastIndex = this.pos;\n        let skip = skipWhiteSpace.exec(this.input);\n        let next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 91 || nextCh === 92)\n            return true;\n        if (context)\n            return false;\n        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320)\n            return true;\n        if (isIdentifierStart(nextCh, true)) {\n            let pos = next + 1;\n            while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true))\n                ++pos;\n            if (nextCh === 92 || nextCh > 55295 && nextCh < 56320)\n                return true;\n            let ident = this.input.slice(next, pos);\n            if (!keywordRelationalOperator.test(ident))\n                return true;\n        }\n        return false;\n    };\n    pp.isAsyncFunction = function () {\n        if (this.options.ecmaVersion < 8 || !this.isContextual('async'))\n            return false;\n        skipWhiteSpace.lastIndex = this.pos;\n        let skip = skipWhiteSpace.exec(this.input);\n        let next = this.pos + skip[0].length, after;\n        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === 'function' && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));\n    };\n    pp.parseStatement = function (context, topLevel, exports) {\n        let starttype = this.type, node = this.startNode(), kind;\n        if (this.isLet(context)) {\n            starttype = tt._var;\n            kind = 'let';\n        }\n        switch (starttype) {\n        case tt._break:\n        case tt._continue:\n            return this.parseBreakContinueStatement(node, starttype.keyword);\n        case tt._debugger:\n            return this.parseDebuggerStatement(node);\n        case tt._do:\n            return this.parseDoStatement(node);\n        case tt._for:\n            return this.parseForStatement(node);\n        case tt._function:\n            if (context && (this.strict || context !== 'if' && context !== 'label') && this.options.ecmaVersion >= 6)\n                this.unexpected();\n            return this.parseFunctionStatement(node, false, !context);\n        case tt._class:\n            if (context)\n                this.unexpected();\n            return this.parseClass(node, true);\n        case tt._if:\n            return this.parseIfStatement(node);\n        case tt._return:\n            return this.parseReturnStatement(node);\n        case tt._switch:\n            return this.parseSwitchStatement(node);\n        case tt._throw:\n            return this.parseThrowStatement(node);\n        case tt._try:\n            return this.parseTryStatement(node);\n        case tt._const:\n        case tt._var:\n            kind = kind || this.value;\n            if (context && kind !== 'var')\n                this.unexpected();\n            return this.parseVarStatement(node, kind);\n        case tt._while:\n            return this.parseWhileStatement(node);\n        case tt._with:\n            return this.parseWithStatement(node);\n        case tt.braceL:\n            return this.parseBlock(true, node);\n        case tt.semi:\n            return this.parseEmptyStatement(node);\n        case tt._export:\n        case tt._import:\n            if (this.options.ecmaVersion > 10 && starttype === tt._import) {\n                skipWhiteSpace.lastIndex = this.pos;\n                let skip = skipWhiteSpace.exec(this.input);\n                let next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                if (nextCh === 40 || nextCh === 46)\n                    return this.parseExpressionStatement(node, this.parseExpression());\n            }\n            if (!this.options.allowImportExportEverywhere) {\n                if (!topLevel)\n                    this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                if (!this.inModule)\n                    this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n            }\n            return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports);\n        default:\n            if (this.isAsyncFunction()) {\n                if (context)\n                    this.unexpected();\n                this.next();\n                return this.parseFunctionStatement(node, true, !context);\n            }\n            let maybeName = this.value, expr = this.parseExpression();\n            if (starttype === tt.name && expr.type === 'Identifier' && this.eat(tt.colon))\n                return this.parseLabeledStatement(node, maybeName, expr, context);\n            else\n                return this.parseExpressionStatement(node, expr);\n        }\n    };\n    pp.parseBreakContinueStatement = function (node, keyword) {\n        let isBreak = keyword === 'break';\n        this.next();\n        if (this.eat(tt.semi) || this.insertSemicolon())\n            node.label = null;\n        else if (this.type !== tt.name)\n            this.unexpected();\n        else {\n            node.label = this.parseIdent();\n            this.semicolon();\n        }\n        let i = 0;\n        for (; i < this.labels.length; ++i) {\n            let lab = this.labels[i];\n            if (node.label == null || lab.name === node.label.name) {\n                if (lab.kind != null && (isBreak || lab.kind === 'loop'))\n                    break;\n                if (node.label && isBreak)\n                    break;\n            }\n        }\n        if (i === this.labels.length)\n            this.raise(node.start, 'Unsyntactic ' + keyword);\n        return this.finishNode(node, isBreak ? 'BreakStatement' : 'ContinueStatement');\n    };\n    pp.parseDebuggerStatement = function (node) {\n        this.next();\n        this.semicolon();\n        return this.finishNode(node, 'DebuggerStatement');\n    };\n    pp.parseDoStatement = function (node) {\n        this.next();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement('do');\n        this.labels.pop();\n        this.expect(tt._while);\n        node.test = this.parseParenExpression();\n        if (this.options.ecmaVersion >= 6)\n            this.eat(tt.semi);\n        else\n            this.semicolon();\n        return this.finishNode(node, 'DoWhileStatement');\n    };\n    pp.parseForStatement = function (node) {\n        this.next();\n        let awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual('await') ? this.lastTokStart : -1;\n        this.labels.push(loopLabel);\n        this.enterScope(0);\n        this.expect(tt.parenL);\n        if (this.type === tt.semi) {\n            if (awaitAt > -1)\n                this.unexpected(awaitAt);\n            return this.parseFor(node, null);\n        }\n        let isLet = this.isLet();\n        if (this.type === tt._var || this.type === tt._const || isLet) {\n            let init = this.startNode(), kind = isLet ? 'let' : this.value;\n            this.next();\n            this.parseVar(init, true, kind);\n            this.finishNode(init, 'VariableDeclaration');\n            if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual('of')) && init.declarations.length === 1) {\n                if (this.options.ecmaVersion >= 9) {\n                    if (this.type === tt._in) {\n                        if (awaitAt > -1)\n                            this.unexpected(awaitAt);\n                    } else\n                        node.await = awaitAt > -1;\n                }\n                return this.parseForIn(node, init);\n            }\n            if (awaitAt > -1)\n                this.unexpected(awaitAt);\n            return this.parseFor(node, init);\n        }\n        let startsWithLet = this.isContextual('let'), isForOf = false;\n        let refDestructuringErrors = new DestructuringErrors();\n        let init = this.parseExpression(awaitAt > -1 ? 'await' : true, refDestructuringErrors);\n        if (this.type === tt._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual('of'))) {\n            if (this.options.ecmaVersion >= 9) {\n                if (this.type === tt._in) {\n                    if (awaitAt > -1)\n                        this.unexpected(awaitAt);\n                } else\n                    node.await = awaitAt > -1;\n            }\n            if (startsWithLet && isForOf)\n                this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n            this.toAssignable(init, false, refDestructuringErrors);\n            this.checkLValPattern(init);\n            return this.parseForIn(node, init);\n        } else {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n        if (awaitAt > -1)\n            this.unexpected(awaitAt);\n        return this.parseFor(node, init);\n    };\n    pp.parseFunctionStatement = function (node, isAsync, declarationPosition) {\n        this.next();\n        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n    };\n    pp.parseIfStatement = function (node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        node.consequent = this.parseStatement('if');\n        node.alternate = this.eat(tt._else) ? this.parseStatement('if') : null;\n        return this.finishNode(node, 'IfStatement');\n    };\n    pp.parseReturnStatement = function (node) {\n        if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n            this.raise(this.start, \"'return' outside of function\");\n        this.next();\n        if (this.eat(tt.semi) || this.insertSemicolon())\n            node.argument = null;\n        else {\n            node.argument = this.parseExpression();\n            this.semicolon();\n        }\n        return this.finishNode(node, 'ReturnStatement');\n    };\n    pp.parseSwitchStatement = function (node) {\n        this.next();\n        node.discriminant = this.parseParenExpression();\n        node.cases = [];\n        this.expect(tt.braceL);\n        this.labels.push(switchLabel);\n        this.enterScope(0);\n        let cur;\n        for (let sawDefault = false; this.type !== tt.braceR;) {\n            if (this.type === tt._case || this.type === tt._default) {\n                let isCase = this.type === tt._case;\n                if (cur)\n                    this.finishNode(cur, 'SwitchCase');\n                node.cases.push(cur = this.startNode());\n                cur.consequent = [];\n                this.next();\n                if (isCase) {\n                    cur.test = this.parseExpression();\n                } else {\n                    if (sawDefault)\n                        this.raiseRecoverable(this.lastTokStart, 'Multiple default clauses');\n                    sawDefault = true;\n                    cur.test = null;\n                }\n                this.expect(tt.colon);\n            } else {\n                if (!cur)\n                    this.unexpected();\n                cur.consequent.push(this.parseStatement(null));\n            }\n        }\n        this.exitScope();\n        if (cur)\n            this.finishNode(cur, 'SwitchCase');\n        this.next();\n        this.labels.pop();\n        return this.finishNode(node, 'SwitchStatement');\n    };\n    pp.parseThrowStatement = function (node) {\n        this.next();\n        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n            this.raise(this.lastTokEnd, 'Illegal newline after throw');\n        node.argument = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, 'ThrowStatement');\n    };\n    const empty = [];\n    pp.parseCatchClauseParam = function () {\n        const param = this.parseBindingAtom();\n        let simple = param.type === 'Identifier';\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(tt.parenR);\n        return param;\n    };\n    pp.parseTryStatement = function (node) {\n        this.next();\n        node.block = this.parseBlock();\n        node.handler = null;\n        if (this.type === tt._catch) {\n            let clause = this.startNode();\n            this.next();\n            if (this.eat(tt.parenL)) {\n                clause.param = this.parseCatchClauseParam();\n            } else {\n                if (this.options.ecmaVersion < 10)\n                    this.unexpected();\n                clause.param = null;\n                this.enterScope(0);\n            }\n            clause.body = this.parseBlock(false);\n            this.exitScope();\n            node.handler = this.finishNode(clause, 'CatchClause');\n        }\n        node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n        if (!node.handler && !node.finalizer)\n            this.raise(node.start, 'Missing catch or finally clause');\n        return this.finishNode(node, 'TryStatement');\n    };\n    pp.parseVarStatement = function (node, kind, allowMissingInitializer) {\n        this.next();\n        this.parseVar(node, false, kind, allowMissingInitializer);\n        this.semicolon();\n        return this.finishNode(node, 'VariableDeclaration');\n    };\n    pp.parseWhileStatement = function (node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement('while');\n        this.labels.pop();\n        return this.finishNode(node, 'WhileStatement');\n    };\n    pp.parseWithStatement = function (node) {\n        if (this.strict)\n            this.raise(this.start, \"'with' in strict mode\");\n        this.next();\n        node.object = this.parseParenExpression();\n        node.body = this.parseStatement('with');\n        return this.finishNode(node, 'WithStatement');\n    };\n    pp.parseEmptyStatement = function (node) {\n        this.next();\n        return this.finishNode(node, 'EmptyStatement');\n    };\n    pp.parseLabeledStatement = function (node, maybeName, expr, context) {\n        for (let label of this.labels)\n            if (label.name === maybeName)\n                this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n        let kind = this.type.isLoop ? 'loop' : this.type === tt._switch ? 'switch' : null;\n        for (let i = this.labels.length - 1; i >= 0; i--) {\n            let label = this.labels[i];\n            if (label.statementStart === node.start) {\n                label.statementStart = this.start;\n                label.kind = kind;\n            } else\n                break;\n        }\n        this.labels.push({\n            name: maybeName,\n            kind,\n            statementStart: this.start\n        });\n        node.body = this.parseStatement(context ? context.indexOf('label') === -1 ? context + 'label' : context : 'label');\n        this.labels.pop();\n        node.label = expr;\n        return this.finishNode(node, 'LabeledStatement');\n    };\n    pp.parseExpressionStatement = function (node, expr) {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, 'ExpressionStatement');\n    };\n    pp.parseBlock = function (createNewLexicalScope = true, node = this.startNode(), exitStrict) {\n        node.body = [];\n        this.expect(tt.braceL);\n        if (createNewLexicalScope)\n            this.enterScope(0);\n        while (this.type !== tt.braceR) {\n            let stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        if (exitStrict)\n            this.strict = false;\n        this.next();\n        if (createNewLexicalScope)\n            this.exitScope();\n        return this.finishNode(node, 'BlockStatement');\n    };\n    pp.parseFor = function (node, init) {\n        node.init = init;\n        this.expect(tt.semi);\n        node.test = this.type === tt.semi ? null : this.parseExpression();\n        this.expect(tt.semi);\n        node.update = this.type === tt.parenR ? null : this.parseExpression();\n        this.expect(tt.parenR);\n        node.body = this.parseStatement('for');\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, 'ForStatement');\n    };\n    pp.parseForIn = function (node, init) {\n        const isForIn = this.type === tt._in;\n        this.next();\n        if (init.type === 'VariableDeclaration' && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== 'var' || init.declarations[0].id.type !== 'Identifier')) {\n            this.raise(init.start, `${ isForIn ? 'for-in' : 'for-of' } loop variable declaration may not have an initializer`);\n        }\n        node.left = init;\n        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n        this.expect(tt.parenR);\n        node.body = this.parseStatement('for');\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, isForIn ? 'ForInStatement' : 'ForOfStatement');\n    };\n    pp.parseVar = function (node, isFor, kind, allowMissingInitializer) {\n        node.declarations = [];\n        node.kind = kind;\n        for (;;) {\n            let decl = this.startNode();\n            this.parseVarId(decl, kind);\n            if (this.eat(tt.eq)) {\n                decl.init = this.parseMaybeAssign(isFor);\n            } else if (!allowMissingInitializer && kind === 'const' && !(this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual('of'))) {\n                this.unexpected();\n            } else if (!allowMissingInitializer && decl.id.type !== 'Identifier' && !(isFor && (this.type === tt._in || this.isContextual('of')))) {\n                this.raise(this.lastTokEnd, 'Complex binding patterns require an initialization value');\n            } else {\n                decl.init = null;\n            }\n            node.declarations.push(this.finishNode(decl, 'VariableDeclarator'));\n            if (!this.eat(tt.comma))\n                break;\n        }\n        return node;\n    };\n    pp.parseVarId = function (decl, kind) {\n        decl.id = this.parseBindingAtom();\n        this.checkLValPattern(decl.id, kind === 'var' ? BIND_VAR : BIND_LEXICAL, false);\n    };\n    const FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n    pp.parseFunction = function (node, statement, allowExpressionBody, isAsync, forInit) {\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n            if (this.type === tt.star && statement & FUNC_HANGING_STATEMENT)\n                this.unexpected();\n            node.generator = this.eat(tt.star);\n        }\n        if (this.options.ecmaVersion >= 8)\n            node.async = !!isAsync;\n        if (statement & FUNC_STATEMENT) {\n            node.id = statement & FUNC_NULLABLE_ID && this.type !== tt.name ? null : this.parseIdent();\n            if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n                this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n        }\n        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(node.async, node.generator));\n        if (!(statement & FUNC_STATEMENT))\n            node.id = this.type === tt.name ? this.parseIdent() : null;\n        this.parseFunctionParams(node);\n        this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, statement & FUNC_STATEMENT ? 'FunctionDeclaration' : 'FunctionExpression');\n    };\n    pp.parseFunctionParams = function (node) {\n        this.expect(tt.parenL);\n        node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n    };\n    pp.parseClass = function (node, isStatement) {\n        this.next();\n        const oldStrict = this.strict;\n        this.strict = true;\n        this.parseClassId(node, isStatement);\n        this.parseClassSuper(node);\n        const privateNameMap = this.enterClassBody();\n        const classBody = this.startNode();\n        let hadConstructor = false;\n        classBody.body = [];\n        this.expect(tt.braceL);\n        while (this.type !== tt.braceR) {\n            const element = this.parseClassElement(node.superClass !== null);\n            if (element) {\n                classBody.body.push(element);\n                if (element.type === 'MethodDefinition' && element.kind === 'constructor') {\n                    if (hadConstructor)\n                        this.raiseRecoverable(element.start, 'Duplicate constructor in the same class');\n                    hadConstructor = true;\n                } else if (element.key && element.key.type === 'PrivateIdentifier' && isPrivateNameConflicted(privateNameMap, element)) {\n                    this.raiseRecoverable(element.key.start, `Identifier '#${ element.key.name }' has already been declared`);\n                }\n            }\n        }\n        this.strict = oldStrict;\n        this.next();\n        node.body = this.finishNode(classBody, 'ClassBody');\n        this.exitClassBody();\n        return this.finishNode(node, isStatement ? 'ClassDeclaration' : 'ClassExpression');\n    };\n    pp.parseClassElement = function (constructorAllowsSuper) {\n        if (this.eat(tt.semi))\n            return null;\n        const ecmaVersion = this.options.ecmaVersion;\n        const node = this.startNode();\n        let keyName = '';\n        let isGenerator = false;\n        let isAsync = false;\n        let kind = 'method';\n        let isStatic = false;\n        if (this.eatContextual('static')) {\n            if (ecmaVersion >= 13 && this.eat(tt.braceL)) {\n                this.parseClassStaticBlock(node);\n                return node;\n            }\n            if (this.isClassElementNameStart() || this.type === tt.star) {\n                isStatic = true;\n            } else {\n                keyName = 'static';\n            }\n        }\n        node.static = isStatic;\n        if (!keyName && ecmaVersion >= 8 && this.eatContextual('async')) {\n            if ((this.isClassElementNameStart() || this.type === tt.star) && !this.canInsertSemicolon()) {\n                isAsync = true;\n            } else {\n                keyName = 'async';\n            }\n        }\n        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(tt.star)) {\n            isGenerator = true;\n        }\n        if (!keyName && !isAsync && !isGenerator) {\n            const lastValue = this.value;\n            if (this.eatContextual('get') || this.eatContextual('set')) {\n                if (this.isClassElementNameStart()) {\n                    kind = lastValue;\n                } else {\n                    keyName = lastValue;\n                }\n            }\n        }\n        if (keyName) {\n            node.computed = false;\n            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n            node.key.name = keyName;\n            this.finishNode(node.key, 'Identifier');\n        } else {\n            this.parseClassElementName(node);\n        }\n        if (ecmaVersion < 13 || this.type === tt.parenL || kind !== 'method' || isGenerator || isAsync) {\n            const isConstructor = !node.static && checkKeyName(node, 'constructor');\n            const allowsDirectSuper = isConstructor && constructorAllowsSuper;\n            if (isConstructor && kind !== 'method')\n                this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n            node.kind = isConstructor ? 'constructor' : kind;\n            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n        } else {\n            this.parseClassField(node);\n        }\n        return node;\n    };\n    pp.isClassElementNameStart = function () {\n        return this.type === tt.name || this.type === tt.privateId || this.type === tt.num || this.type === tt.string || this.type === tt.bracketL || this.type.keyword;\n    };\n    pp.parseClassElementName = function (element) {\n        if (this.type === tt.privateId) {\n            if (this.value === 'constructor') {\n                this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n            }\n            element.computed = false;\n            element.key = this.parsePrivateIdent();\n        } else {\n            this.parsePropertyName(element);\n        }\n    };\n    pp.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {\n        const key = method.key;\n        if (method.kind === 'constructor') {\n            if (isGenerator)\n                this.raise(key.start, \"Constructor can't be a generator\");\n            if (isAsync)\n                this.raise(key.start, \"Constructor can't be an async method\");\n        } else if (method.static && checkKeyName(method, 'prototype')) {\n            this.raise(key.start, 'Classes may not have a static property named prototype');\n        }\n        const value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n        if (method.kind === 'get' && value.params.length !== 0)\n            this.raiseRecoverable(value.start, 'getter should have no params');\n        if (method.kind === 'set' && value.params.length !== 1)\n            this.raiseRecoverable(value.start, 'setter should have exactly one param');\n        if (method.kind === 'set' && value.params[0].type === 'RestElement')\n            this.raiseRecoverable(value.params[0].start, 'Setter cannot use rest params');\n        return this.finishNode(method, 'MethodDefinition');\n    };\n    pp.parseClassField = function (field) {\n        if (checkKeyName(field, 'constructor')) {\n            this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n        } else if (field.static && checkKeyName(field, 'prototype')) {\n            this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n        }\n        if (this.eat(tt.eq)) {\n            const scope = this.currentThisScope();\n            const inClassFieldInit = scope.inClassFieldInit;\n            scope.inClassFieldInit = true;\n            field.value = this.parseMaybeAssign();\n            scope.inClassFieldInit = inClassFieldInit;\n        } else {\n            field.value = null;\n        }\n        this.semicolon();\n        return this.finishNode(field, 'PropertyDefinition');\n    };\n    pp.parseClassStaticBlock = function (node) {\n        node.body = [];\n        let oldLabels = this.labels;\n        this.labels = [];\n        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n        while (this.type !== tt.braceR) {\n            let stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        this.next();\n        this.exitScope();\n        this.labels = oldLabels;\n        return this.finishNode(node, 'StaticBlock');\n    };\n    pp.parseClassId = function (node, isStatement) {\n        if (this.type === tt.name) {\n            node.id = this.parseIdent();\n            if (isStatement)\n                this.checkLValSimple(node.id, BIND_LEXICAL, false);\n        } else {\n            if (isStatement === true)\n                this.unexpected();\n            node.id = null;\n        }\n    };\n    pp.parseClassSuper = function (node) {\n        node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts(null, false) : null;\n    };\n    pp.enterClassBody = function () {\n        const element = {\n            declared: Object.create(null),\n            used: []\n        };\n        this.privateNameStack.push(element);\n        return element.declared;\n    };\n    pp.exitClassBody = function () {\n        const {declared, used} = this.privateNameStack.pop();\n        if (!this.options.checkPrivateFields)\n            return;\n        const len = this.privateNameStack.length;\n        const parent = len === 0 ? null : this.privateNameStack[len - 1];\n        for (let i = 0; i < used.length; ++i) {\n            const id = used[i];\n            if (!hasOwn(declared, id.name)) {\n                if (parent) {\n                    parent.used.push(id);\n                } else {\n                    this.raiseRecoverable(id.start, `Private field '#${ id.name }' must be declared in an enclosing class`);\n                }\n            }\n        }\n    };\n    function isPrivateNameConflicted(privateNameMap, element) {\n        const name = element.key.name;\n        const curr = privateNameMap[name];\n        let next = 'true';\n        if (element.type === 'MethodDefinition' && (element.kind === 'get' || element.kind === 'set')) {\n            next = (element.static ? 's' : 'i') + element.kind;\n        }\n        if (curr === 'iget' && next === 'iset' || curr === 'iset' && next === 'iget' || curr === 'sget' && next === 'sset' || curr === 'sset' && next === 'sget') {\n            privateNameMap[name] = 'true';\n            return false;\n        } else if (!curr) {\n            privateNameMap[name] = next;\n            return false;\n        } else {\n            return true;\n        }\n    }\n    function checkKeyName(node, name) {\n        const {computed, key} = node;\n        return !computed && (key.type === 'Identifier' && key.name === name || key.type === 'Literal' && key.value === name);\n    }\n    pp.parseExportAllDeclaration = function (node, exports) {\n        if (this.options.ecmaVersion >= 11) {\n            if (this.eatContextual('as')) {\n                node.exported = this.parseModuleExportName();\n                this.checkExport(exports, node.exported, this.lastTokStart);\n            } else {\n                node.exported = null;\n            }\n        }\n        this.expectContextual('from');\n        if (this.type !== tt.string)\n            this.unexpected();\n        node.source = this.parseExprAtom();\n        this.semicolon();\n        return this.finishNode(node, 'ExportAllDeclaration');\n    };\n    pp.parseExport = function (node, exports) {\n        this.next();\n        if (this.eat(tt.star)) {\n            return this.parseExportAllDeclaration(node, exports);\n        }\n        if (this.eat(tt._default)) {\n            this.checkExport(exports, 'default', this.lastTokStart);\n            node.declaration = this.parseExportDefaultDeclaration();\n            return this.finishNode(node, 'ExportDefaultDeclaration');\n        }\n        if (this.shouldParseExportStatement()) {\n            node.declaration = this.parseExportDeclaration(node);\n            if (node.declaration.type === 'VariableDeclaration')\n                this.checkVariableExport(exports, node.declaration.declarations);\n            else\n                this.checkExport(exports, node.declaration.id, node.declaration.id.start);\n            node.specifiers = [];\n            node.source = null;\n        } else {\n            node.declaration = null;\n            node.specifiers = this.parseExportSpecifiers(exports);\n            if (this.eatContextual('from')) {\n                if (this.type !== tt.string)\n                    this.unexpected();\n                node.source = this.parseExprAtom();\n            } else {\n                for (let spec of node.specifiers) {\n                    this.checkUnreserved(spec.local);\n                    this.checkLocalExport(spec.local);\n                    if (spec.local.type === 'Literal') {\n                        this.raise(spec.local.start, 'A string literal cannot be used as an exported binding without `from`.');\n                    }\n                }\n                node.source = null;\n            }\n            this.semicolon();\n        }\n        return this.finishNode(node, 'ExportNamedDeclaration');\n    };\n    pp.parseExportDeclaration = function (node) {\n        return this.parseStatement(null);\n    };\n    pp.parseExportDefaultDeclaration = function () {\n        let isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n            let fNode = this.startNode();\n            this.next();\n            if (isAsync)\n                this.next();\n            return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n            let cNode = this.startNode();\n            return this.parseClass(cNode, 'nullableID');\n        } else {\n            let declaration = this.parseMaybeAssign();\n            this.semicolon();\n            return declaration;\n        }\n    };\n    pp.checkExport = function (exports, name, pos) {\n        if (!exports)\n            return;\n        if (typeof name !== 'string')\n            name = name.type === 'Identifier' ? name.name : name.value;\n        if (hasOwn(exports, name))\n            this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n        exports[name] = true;\n    };\n    pp.checkPatternExport = function (exports, pat) {\n        let type = pat.type;\n        if (type === 'Identifier')\n            this.checkExport(exports, pat, pat.start);\n        else if (type === 'ObjectPattern')\n            for (let prop of pat.properties)\n                this.checkPatternExport(exports, prop);\n        else if (type === 'ArrayPattern')\n            for (let elt of pat.elements) {\n                if (elt)\n                    this.checkPatternExport(exports, elt);\n            }\n        else if (type === 'Property')\n            this.checkPatternExport(exports, pat.value);\n        else if (type === 'AssignmentPattern')\n            this.checkPatternExport(exports, pat.left);\n        else if (type === 'RestElement')\n            this.checkPatternExport(exports, pat.argument);\n        else if (type === 'ParenthesizedExpression')\n            this.checkPatternExport(exports, pat.expression);\n    };\n    pp.checkVariableExport = function (exports, decls) {\n        if (!exports)\n            return;\n        for (let decl of decls)\n            this.checkPatternExport(exports, decl.id);\n    };\n    pp.shouldParseExportStatement = function () {\n        return this.type.keyword === 'var' || this.type.keyword === 'const' || this.type.keyword === 'class' || this.type.keyword === 'function' || this.isLet() || this.isAsyncFunction();\n    };\n    pp.parseExportSpecifier = function (exports) {\n        let node = this.startNode();\n        node.local = this.parseModuleExportName();\n        node.exported = this.eatContextual('as') ? this.parseModuleExportName() : node.local;\n        this.checkExport(exports, node.exported, node.exported.start);\n        return this.finishNode(node, 'ExportSpecifier');\n    };\n    pp.parseExportSpecifiers = function (exports) {\n        let nodes = [], first = true;\n        this.expect(tt.braceL);\n        while (!this.eat(tt.braceR)) {\n            if (!first) {\n                this.expect(tt.comma);\n                if (this.afterTrailingComma(tt.braceR))\n                    break;\n            } else\n                first = false;\n            nodes.push(this.parseExportSpecifier(exports));\n        }\n        return nodes;\n    };\n    pp.parseImport = function (node) {\n        this.next();\n        if (this.type === tt.string) {\n            node.specifiers = empty;\n            node.source = this.parseExprAtom();\n        } else {\n            node.specifiers = this.parseImportSpecifiers();\n            this.expectContextual('from');\n            node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n        }\n        this.semicolon();\n        return this.finishNode(node, 'ImportDeclaration');\n    };\n    pp.parseImportSpecifier = function () {\n        let node = this.startNode();\n        node.imported = this.parseModuleExportName();\n        if (this.eatContextual('as')) {\n            node.local = this.parseIdent();\n        } else {\n            this.checkUnreserved(node.imported);\n            node.local = node.imported;\n        }\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, 'ImportSpecifier');\n    };\n    pp.parseImportDefaultSpecifier = function () {\n        let node = this.startNode();\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, 'ImportDefaultSpecifier');\n    };\n    pp.parseImportNamespaceSpecifier = function () {\n        let node = this.startNode();\n        this.next();\n        this.expectContextual('as');\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, 'ImportNamespaceSpecifier');\n    };\n    pp.parseImportSpecifiers = function () {\n        let nodes = [], first = true;\n        if (this.type === tt.name) {\n            nodes.push(this.parseImportDefaultSpecifier());\n            if (!this.eat(tt.comma))\n                return nodes;\n        }\n        if (this.type === tt.star) {\n            nodes.push(this.parseImportNamespaceSpecifier());\n            return nodes;\n        }\n        this.expect(tt.braceL);\n        while (!this.eat(tt.braceR)) {\n            if (!first) {\n                this.expect(tt.comma);\n                if (this.afterTrailingComma(tt.braceR))\n                    break;\n            } else\n                first = false;\n            nodes.push(this.parseImportSpecifier());\n        }\n        return nodes;\n    };\n    pp.parseModuleExportName = function () {\n        if (this.options.ecmaVersion >= 13 && this.type === tt.string) {\n            const stringLiteral = this.parseLiteral(this.value);\n            if (loneSurrogate.test(stringLiteral.value)) {\n                this.raise(stringLiteral.start, 'An export name cannot include a lone surrogate.');\n            }\n            return stringLiteral;\n        }\n        return this.parseIdent(true);\n    };\n    pp.adaptDirectivePrologue = function (statements) {\n        for (let i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n            statements[i].directive = statements[i].expression.raw.slice(1, -1);\n        }\n    };\n    pp.isDirectiveCandidate = function (statement) {\n        return this.options.ecmaVersion >= 5 && statement.type === 'ExpressionStatement' && statement.expression.type === 'Literal' && typeof statement.expression.value === 'string' && (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n    };\n});"]}