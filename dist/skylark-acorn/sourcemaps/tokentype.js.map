{"version":3,"sources":["tokentype.js"],"names":["define","TokenType","[object Object]","label","conf","this","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","name","prec","keywords","kw","options","types","num","regexp","string","privateId","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","questionDot","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","coalesce","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete"],"mappings":"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","file":"../tokentype.js","sourcesContent":["define(function () {\n    'use strict';\n    class TokenType {\n        constructor(label, conf = {}) {\n            this.label = label;\n            this.keyword = conf.keyword;\n            this.beforeExpr = !!conf.beforeExpr;\n            this.startsExpr = !!conf.startsExpr;\n            this.isLoop = !!conf.isLoop;\n            this.isAssign = !!conf.isAssign;\n            this.prefix = !!conf.prefix;\n            this.postfix = !!conf.postfix;\n            this.binop = conf.binop || null;\n            this.updateContext = null;\n        }\n    }\n    function binop(name, prec) {\n        return new TokenType(name, {\n            beforeExpr: true,\n            binop: prec\n        });\n    }\n    const beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };\n    const keywords = {};\n    function kw(name, options = {}) {\n        options.keyword = name;\n        return keywords[name] = new TokenType(name, options);\n    }\n    const types = {\n        num: new TokenType('num', startsExpr),\n        regexp: new TokenType('regexp', startsExpr),\n        string: new TokenType('string', startsExpr),\n        name: new TokenType('name', startsExpr),\n        privateId: new TokenType('privateId', startsExpr),\n        eof: new TokenType('eof'),\n        bracketL: new TokenType('[', {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        bracketR: new TokenType(']'),\n        braceL: new TokenType('{', {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        braceR: new TokenType('}'),\n        parenL: new TokenType('(', {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        parenR: new TokenType(')'),\n        comma: new TokenType(',', beforeExpr),\n        semi: new TokenType(';', beforeExpr),\n        colon: new TokenType(':', beforeExpr),\n        dot: new TokenType('.'),\n        question: new TokenType('?', beforeExpr),\n        questionDot: new TokenType('?.'),\n        arrow: new TokenType('=>', beforeExpr),\n        template: new TokenType('template'),\n        invalidTemplate: new TokenType('invalidTemplate'),\n        ellipsis: new TokenType('...', beforeExpr),\n        backQuote: new TokenType('`', startsExpr),\n        dollarBraceL: new TokenType('${', {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        eq: new TokenType('=', {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        assign: new TokenType('_=', {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        incDec: new TokenType('++/--', {\n            prefix: true,\n            postfix: true,\n            startsExpr: true\n        }),\n        prefix: new TokenType('!/~', {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        logicalOR: binop('||', 1),\n        logicalAND: binop('&&', 2),\n        bitwiseOR: binop('|', 3),\n        bitwiseXOR: binop('^', 4),\n        bitwiseAND: binop('&', 5),\n        equality: binop('==/!=/===/!==', 6),\n        relational: binop('</>/<=/>=', 7),\n        bitShift: binop('<</>>/>>>', 8),\n        plusMin: new TokenType('+/-', {\n            beforeExpr: true,\n            binop: 9,\n            prefix: true,\n            startsExpr: true\n        }),\n        modulo: binop('%', 10),\n        star: binop('*', 10),\n        slash: binop('/', 10),\n        starstar: new TokenType('**', { beforeExpr: true }),\n        coalesce: binop('??', 1),\n        _break: kw('break'),\n        _case: kw('case', beforeExpr),\n        _catch: kw('catch'),\n        _continue: kw('continue'),\n        _debugger: kw('debugger'),\n        _default: kw('default', beforeExpr),\n        _do: kw('do', {\n            isLoop: true,\n            beforeExpr: true\n        }),\n        _else: kw('else', beforeExpr),\n        _finally: kw('finally'),\n        _for: kw('for', { isLoop: true }),\n        _function: kw('function', startsExpr),\n        _if: kw('if'),\n        _return: kw('return', beforeExpr),\n        _switch: kw('switch'),\n        _throw: kw('throw', beforeExpr),\n        _try: kw('try'),\n        _var: kw('var'),\n        _const: kw('const'),\n        _while: kw('while', { isLoop: true }),\n        _with: kw('with'),\n        _new: kw('new', {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        _this: kw('this', startsExpr),\n        _super: kw('super', startsExpr),\n        _class: kw('class', startsExpr),\n        _extends: kw('extends', beforeExpr),\n        _export: kw('export'),\n        _import: kw('import', startsExpr),\n        _null: kw('null', startsExpr),\n        _true: kw('true', startsExpr),\n        _false: kw('false', startsExpr),\n        _in: kw('in', {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _instanceof: kw('instanceof', {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _typeof: kw('typeof', {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _void: kw('void', {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _delete: kw('delete', {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        })\n    };\n    return {\n        TokenType: TokenType,\n        keywords: keywords,\n        types: types\n    };\n});"]}